{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>TrenchBoot is a framework that allows individuals and projects to build security engines to perform launch integrity actions for their systems. The framework builds upon Boot Integrity Technologies (BITs) that establish one or more Roots of Trust (RoT) from which a degree of confidence that integrity actions were not subverted is derived.</p>"},{"location":"#where-to-start","title":"Where to Start","text":"<ul> <li>User Documentation - Requirements and quick start guides</li> <li>General Architecture - A top level overview of   TrenchBoot</li> <li>Use Case Definition - A collection of example use cases</li> <li>Developers Guide - A developers guide that   explains the internals of TrenchBoot</li> </ul>"},{"location":"#contributors","title":"Contributors","text":""},{"location":"FAQ/","title":"TrenchBoot FAQ","text":"<ol> <li>Why use TrenchBoot?</li> <li>How does TrenchBoot work?</li> <li>What is the TrenchBoot intermediate loader?</li> <li>How do measurement trust chains contrast with verification trust chains?</li> <li>What do I need to incorporate TrenchBoot into my system?</li> <li>Where do I start if I want to help with contributions?</li> </ol>"},{"location":"FAQ/#1-why-use-trenchboot-background-info","title":"1. Why use TrenchBoot? (background info)","text":""},{"location":"FAQ/#what-is-trust","title":"What is Trust?","text":"<p>Trust is an assured reliance on the properties, ability, strength, or truth of an entity (see Glossary). If we assume any information or property is true without measuring and proving it, we need to trust it. This might include the belief that our computer will behave in an expected way, that it won't leak our data, and that it won't do something we didn't intend or expect.</p> <p>When establishing the trust of system components, there are two primary schools of thought: Static Root of Trust for Measurement (SRTM) and Dynamic Root of Trust for Measurement (DRTM).</p>"},{"location":"FAQ/#srtm","title":"SRTM","text":"<p>SRTM Starts with Core Root of Trust for Measurement (CRTM), and works its way up the chain where each link verifies the next. In other words, SRTM starts by measuring the BIOS boot block and moves on to measure the rest of the BIOS. SRTM has a few problems:</p> <ul> <li>Large TCB (Trusted Computing Base): the more software added to the chain of trust, the more potential vectors of attack.</li> <li>Takes place before boot: reassuring the validity of the chain of trust requires a reboot.</li> <li>Only provides load-time integrity assurance: integrity is maintained during boot, but there is no guarantee it will remain so.</li> </ul>"},{"location":"FAQ/#drtm","title":"DRTM","text":"<p>DRTM aims to address shortcomings of SRTM. DRTM creates a trusted environment from an untrusted state. Essentially what this means is that regardless of whether or not computer was booted from trusted software, it uses hardware to ensure that no malicious software, which may or may not have been run before the dynamic launch, can impact software started after the dynamic launch. For this reason, DRTM takes place after boot, as opposed to SRTM, which takes place pre-boot. Intel's solution for DRTM is TXT, which utilizes special instructions on the processor (SMX). AMD's solution for DRTM is called SKINIT. Overall, TrenchBoot provides a solution for setting up DRTM for an arbitrary platform.</p>"},{"location":"FAQ/#typical-measured-launch-process","title":"Typical Measured Launch Process","text":"<p>The process for carrying out DTRM depends on your system:</p> <ul> <li>Intel TXT: Software Development Guide</li> <li>System Programming Volume of for AMD64 (PDF) (see   \"Secure Startup with SKINIT\" section)</li> </ul>"},{"location":"FAQ/#why-trenchboot","title":"Why TrenchBoot?","text":"<ul> <li>Managing multiple independent components individually can be confusing</li> <li>Most DRTM systems are platform-dependent</li> <li>Most DRTM systems can only measure entities already present in RAM at the     time DRTM sequence is initiated</li> <li>Most DRTM systems support only one attestation action</li> </ul> <p>TrenchBoot is meant to solve these and many other problems by providing a universal framework for building integrity of software components in the process of booting a computer system.</p>"},{"location":"FAQ/#2-how-does-trenchboot-work-trenchboot-architecture","title":"2. How does TrenchBoot work? (TrenchBoot architecture)","text":""},{"location":"FAQ/#architecture-overview","title":"Architecture Overview","text":"<p>The full architecture overview can be found on the corresponding page.  This diagram shows a general overview of the overall architecture of a TrenchBoot system. In Bootstrap phase, the system environment is measured and that information stored in the dynamic PCRs using whatever method is appropriate for the given hardware. The intermediate phase analyzes the information collected in the bootstrap phase to decide whether it wants to continue booting and pass control to the target OS or if it wants to stop immediately. If desired, additional evidence/measurements can be gathered in this phase. Once the integrity of the system is verified, the TrenchBoot kernel passes off control to the actual desired OS to initiate the runtime phase.</p>"},{"location":"FAQ/#bootstrap-phase-grub","title":"Bootstrap Phase - GRUB","text":"<p>GRUB has commands built in to carry out a TrenchBoot Secure Launch (currently supporting Intel TXT and AMD SKINIT). This is typically called the pre-launch or preamble phase of the launch. These commands are <code>slaunch</code> and <code>slaunch_module</code>.</p> <p>The custom GRUB works with:</p> <ul> <li>Linux boot protocol (Intel only, legacy and UEFI)</li> <li>Multiboot2 boot protocol (both Intel and AMD, but only legacy boot)</li> </ul> <p>Support for AMD Linux and Multiboot2 UEFI will be added later.</p>"},{"location":"FAQ/#intermediate-phase-linux-kernel-u-root-initramfs","title":"Intermediate Phase - Linux Kernel / U-ROOT (Initramfs)","text":"<p>The intermediate phase processes information collected in the bootstrap phase and converts it into normalized data. This data is eventually used to determine whether to boot into the target OS. Together the kernel and u-root initramfs make up TrenchBoot's Security Engine, an intermediate mini-OS that processes data gathered by that bootstrap phase. During the intermediate phase, the kernel and initramfs work together to measure block devices, individual files, SMBUS/DMI information, etc. The kernel and initramfs also provide unseal based, external device and network based attestation. TrenchBoot calls this functionality Secure Launch (aka slaunch).</p>"},{"location":"FAQ/#3-what-is-the-trenchboot-intermediate-loader","title":"3. What is the TrenchBoot intermediate loader?","text":"<p>For Linux systems doing both verified (secure) and measured boot, there is an intermediary that handles the security enforcement. For verified boot, the intermediary is the UEFI shim loader and for measured boot, it is tboot. One of the use cases for TrenchBoot is a drop-in replacement of tboot, hence a common Linux-based loader that provides a rich security processing framework is used as an intermediate stage. This allows for easy modifications to the framework in an environment that most developers are familiar with. Other use cases may choose to modify this stage, or drop it altogether if the security processing is done in the final payload.</p> <p>Intermediate loader tends to be the most common DRTM use case, it's how tboot works and how Microsoft's Secure Core DRTM works. It allows for starting existing operating systems with minimal or no changes.</p>"},{"location":"FAQ/#4-how-do-measurement-trust-chains-contrast-with-verification-trust-chains","title":"4. How do measurement trust chains contrast with verification trust chains?","text":"<p>It is important to understand that one solution is not necessarily more beneficial over the other. Measurement and Verification each have their merits and it is important to understand the environment and requirements of the solution. In the case of verification, it provides a one-time strong assertion to origination and correctness that relies on Authorities and Control which becomes brittle when dealing with delegating control. For example when verification is being used as the Root of Trust that the transitive trust builds upon, these solutions are strongest when the ecosystem is closed and under control of a core entity. Where as measurement provides for establishing a strong assertion to correctness that can be repeatedly extended and verified. It therefore relies on the ability to know what correct is and to securely verify measurement with expected correctness.</p>"},{"location":"FAQ/#5-what-do-i-need-to-incorporate-trenchboot-into-my-system","title":"5. What do I need to incorporate TrenchBoot into my system?","text":"<p>TrenchBoot is a framework that allows you to build a Linux kernel with a tailored, embedded initramfs that functions as an intermediate loader to launch your system. You will need to use the build system to select the security engine components you desire, provide any necessary configurations, and build an instance of the loader. Next, configure your system boot to launch the loader.</p>"},{"location":"FAQ/#6-where-do-i-start-if-i-want-to-help-with-contributions","title":"6. Where do I start if I want to help with contributions?","text":"<p>TrenchBoot Blueprints collect product feature requests. Check to see if there is an existing blueprint that addresses your feature request. You may also submit a blueprint via pull request to suggest features for implementation.</p>"},{"location":"community/","title":"How to get in contact with the team","text":"<ul> <li>TrenchBoot Google Group</li> <li>Twitter</li> <li>TrenchBoot room on Matrix</li> </ul>"},{"location":"events/","title":"Conferences","text":"<p>Events that TrenchBoot appeared on.</p>"},{"location":"events/#worldwide-conferences","title":"Worldwide conferences","text":"<ul> <li>Xen Project Summit 2024<ul> <li>Video: Challenges and Status of Enabling TrenchBoot in Xen Hypervisor</li> <li>Slides</li> </ul> </li> <li>FOSDEM 2024<ul> <li>Video: TrenchBoot - project status update</li> <li>Slides (DRTM Status)</li> <li>Slides (TrenchBoot AEM Status)</li> </ul> </li> <li>Xen Developer &amp; Design Summit 2023<ul> <li>Video: Paving the Path for TrenchBoot DRTM in Xen Hypervisor</li> <li>Slides</li> </ul> </li> <li>Qubes OS Summit 2022<ul> <li>Video: TrenchBoot - The only AEM-way to boot Qubes OS</li> <li>Slides</li> </ul> </li> <li>Linux Plumbers Conference 2022<ul> <li>Video: TrenchBoot Update</li> <li>Slides</li> </ul> </li> <li>FOSDEM 2021<ul> <li>Video: Secure Upgrades with DRTM</li> </ul> </li> <li>Open Source Firmware Conference 2020<ul> <li>Video: TrenchBoot DRTM features for AMD platforms</li> <li>Slides</li> </ul> </li> <li>UEFI Plugfest 2020<ul> <li>Video: TrenchBoot and GRUB - A Quick Introduction</li> <li>Slides</li> </ul> </li> <li>Xen Project Developer and Design Summit 2020<ul> <li>Video: Xen system boot attestation with DRTM and TPM2</li> <li>Slides</li> </ul> </li> <li>FOSDEM 2020<ul> <li>Video : Improving the Security of Edge Computing Services</li> <li>Slides (part1)</li> <li>Slides (part2)</li> </ul> </li> <li>Platform Security Summit 2019<ul> <li>Slides</li> </ul> </li> <li>Xen Project Developer and Design Summit 2019<ul> <li>Video: How TrenchBoot is Enabling Measured Launch for Open-Source Platform Security</li> <li>Slides</li> </ul> </li> <li>Linux Plumbers Conference 2019<ul> <li>Video: TrenchBoot - How to Nicely Boot System with Intel TXT and AMD SVM</li> <li>Slides</li> </ul> </li> <li>Linux Security Summit 2019<ul> <li>Video: TrenchBoot - How to Nicely Boot System with Intel TXT and AMD SVM</li> <li>Slides</li> </ul> </li> <li>Open Source Firmware Conference 2019<ul> <li>Video: TrenchBoot - Open DRTM implementation for AMD platforms</li> <li>Slides</li> </ul> </li> <li>Grub2 and 3mdeb \"minisummit\" 2019<ul> <li>Video: AMD TrenchBoot support in GRUB2</li> <li>Slides</li> </ul> </li> <li>Platform Security Summit 2018<ul> <li>Video: TrenchBoot and System Boot Integrity</li> <li>Slides</li> </ul> </li> </ul>"},{"location":"events/#trenchboot-events","title":"TrenchBoot events","text":"<ul> <li>Linux Secure Launch - TrenchBoot Summit 2021</li> <li>TrenchBoot Developers Forum 2021</li> </ul>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#cross-links-to-publications-mentioning-trenchboot","title":"Cross-links to publications mentioning TrenchBoot","text":""},{"location":"publications/#scientific-publications","title":"Scientific Publications","text":"<ul> <li>Mathias Sch\u00fcpany, Martin Pirker: A Revisit of Attestable Nodes for     Networked Applications</li> <li>Jasmin Marmsoler, Thomas Grechenig, Florian Fankhauser:     TPM 2.0 als Sicherheitsma\u00dfnahme gegen Rootkits      auf Linux-basierten Desktop-Systemen (German)</li> </ul>"},{"location":"publications/#books","title":"Books","text":"<ul> <li>Jiewen Yao, Vincent Zimmer: Building Secure Firmware</li> </ul>"},{"location":"publications/#blog-posts","title":"Blog posts","text":"<ul> <li>TrenchBoot Anti Evil Maid - Phase 4</li> <li>TrenchBoot Anti Evil Maid - Phase 3</li> <li>TrenchBoot Anti Evil Maid - Phase 2</li> <li>TrenchBoot Anti Evil Maid for Qubes OS</li> <li>Proof of concept implementation of RATS attestation for the TrenchBoot</li> <li>TrenchBoot: Xen hypervisor support for the TrenchBoot</li> <li>TrenchBoot: Open Source DRTM. Multiboot2 support.</li> <li>TrenchBoot: Open Source DRTM. TPM event log all the way.</li> <li>DEV and IOMMU: a story of two DMA protection mechanisms</li> <li>TrenchBoot: Open Source DRTM. GRUB's new features and TPM event log.</li> <li>Starting TrenchBoot's Landing Zone from iPXE</li> <li>Installing TrenchBoot in UEFI environments</li> <li>TrenchBoot: Open Source DRTM. CI/CD system.</li> <li>TrenchBoot: Open Source DRTM. DRTM update and meta-trenchboot implementation</li> <li>TrenchBoot: Open Source DRTM. Landing Zone validation.</li> <li>TrenchBoot - Open Source DRTM for AMD processors. Project's basics.</li> <li>Open Source DRTM with TrenchBoot for AMD processors. Introduction.</li> </ul>"},{"location":"upcoming_events/","title":"Upcoming Events","text":""},{"location":"blueprints/","title":"Blueprints","text":"<p>Here you will find the design artifacts for built, in progress, and planned security engine components:</p> <p>{nav}</p>"},{"location":"blueprints/#components","title":"Components","text":"Component DRTM Description ACM TXT DCE for TXT made and signed by Intel GRUB2 TXT, SKINIT Secure Launch enabled bootloader Linux TXT Secure Launch enabled Unix-like kernel SKL SKINIT Free and open source DCE for AMD SKINIT SLRT TXT, SKINIT Data format for sharing information among components Xen TXT, SKINIT Secure Launch enabled type-1 hypervisor"},{"location":"blueprints/#boot-process","title":"Boot process","text":"<p>The control passes from a bootloader to DCE and into DLME with each performing its part:</p> <ol> <li>GRUB2<ol> <li><code>slaunch</code> command is used to enable Secure Launch.  It verifies that the    platform is supported or prints an error and fails.    In case of TXT, the command also fails if the last Secure Launch attempt    has failed (the error can result in a soft reset after storing error code    in a register whose value is analyzed on the next boot).</li> <li><code>slaunch_module</code> command is run to provide DCEs.  This is always    needed for SKINIT and sometimes not needed for TXT if BIOS has already    loaded it.  The command discards unsupported DCEs and thus can be used to    offer GRUB2 a set of DCEs\u00a0one at a time and let it figure out which is    the correct one.</li> <li>Construct SLRT.</li> <li>Perform boot\u00a0using normal GRUB2 commands, although not all of them    support Secure Launch (see below).  Possibly error if something goes    wrong during Secure Launch.</li> </ol> </li> <li>DCE\u00a0(ACM or SKL)<ol> <li>Initialize hardware state for DRTM.</li> <li>Perform TPM measurements.</li> <li>Start execution of DLME if there are no errors with data or system's    state in general.</li> </ol> </li> <li>DLME\u00a0(Linux or Xen)<ol> <li>Detect that Secure Launch is in effect.</li> <li>Find out where SLRT is.</li> <li>Perform actions specific to a particular DRTM implementation.</li> <li>Process SLRT\u00a0(e.g., DRTM measurement policy).</li> <li>Boot as usual.</li> </ol> </li> </ol>"},{"location":"blueprints/#boot-protocols-in-grub2","title":"Boot protocols in GRUB2","text":"<p>A summary of currently available implementations:</p> DRTM Linux EFI Stub Multiboot2 TXT Yes On a separate branch Yes SKINIT Yes No Yes"},{"location":"blueprints/#upstreaming-status-as-of-31-august-2024","title":"Upstreaming status (as of 31 August 2024)","text":"<p>Components to which upstreaming doesn't apply were left out from the table.</p> Component Upstream Qubes OS GRUB2 Sent Yes SKL Part of TrenchBoot No Linux In Progress N/A Xen Partially In Progress In Progress"},{"location":"blueprints/AMD_Grub_Late_Launch/","title":"AMD Grub Late Launcher","text":""},{"location":"blueprints/AMD_Grub_Late_Launch/#purpose","title":"Purpose","text":"<p>The intent of this project is to extend Grub with the ability to call the AMD SKINIT instruction.</p>"},{"location":"blueprints/AMD_Grub_Late_Launch/#background","title":"Background","text":"<p>The AMD SKINIT instruction is a means to initiate a \"late launch\" that establishes a Dynamic Root of Trust Measurement (DRTM). The instruction call requires the system to be in a specific state as enumerated below,</p> <ul> <li>SVM check, either the <code>EFER.SVME</code> bit is set to 1 or the feature flag <code>CPUID   Fn8000_0001_ECX[SKINIT]</code> is set to 1</li> <li>The CPU must be in protected mode</li> </ul>"},{"location":"blueprints/AMD_Grub_Late_Launch/#approach","title":"Approach","text":"<p>Grub will be extended with the following capabilities,</p> <ul> <li>Extend the late launch loader,<ol> <li>determine CPU type and select SKINIT or SENTER path</li> <li>load kernel (with modules, if applicable) as usual</li> <li>verify SVM is supported</li> <li>load Secure Kernel Loader and check if it is valid</li> <li>allocate and fill Secure Launch Resource Table</li> <li>send INIT IPI to all APs</li> <li>disable all TPM localities</li> </ol> </li> <li>An SKINIT relocator that will,<ol> <li>set protected mode</li> <li>set registers as required by SKINIT</li> <li>execute SKINIT as final instruction</li> </ol> </li> </ul>"},{"location":"blueprints/AMD_Secure_Kernel_Loader/","title":"AMD Secure Kernel Loader","text":""},{"location":"blueprints/AMD_Secure_Kernel_Loader/#purpose","title":"Purpose","text":"<p>The intent of this project is to implement the earliest code that is launched by a DL Event on AMD platforms.</p>"},{"location":"blueprints/AMD_Secure_Kernel_Loader/#background","title":"Background","text":"<p>Contrary to the TXT solution, SKINIT is a single CPU instruction after which the execution is passed to the user-provided block of code, called Secure Loader in AMD documents. To some extent, this code can be treated as the AMD equivalent of ACM, except that it doesn't have to be signed by the CPU vendor.</p> <p>SKINIT extends PCR17 with the hash of SL (Secure Loader), which size is specified in the SL header (maximum of 64K - 1), protects SLB (Secure Launch Block, always 64K) against DMA access from the devices, puts the CPU in defined execution state and jumps to the entry point also specified in the header. At the entry point to the SL the CPU works in flat 32-bit protected mode with paging disabled. Most general purpose registers are cleared. Interrupts are disabled (held pending until re-enabled), including NMI, SMI and INIT. Refer to AMD APM Vol 2 for more details.</p> <p>Secure Kernel Loader (SKL) is an implementation of Secure Loader.</p>"},{"location":"blueprints/AMD_Secure_Kernel_Loader/#approach","title":"Approach","text":"<p>This is a high-level overview of tasks performed by Secure Kernel Loader:</p> <ol> <li>set GDT and segment registers (only CS and SS are valid after SKINIT)</li> <li>set up pagetables and enable Long Mode (optional, see <code>BITS</code> in    Build options)</li> <li>initialize TPM interface</li> <li>initialize TPM event log<ul> <li>log what was done by SKINIT</li> </ul> </li> <li>extend PCR18 with the hash of SLRT (Secure Launch Resource Table) passed by    the bootloader to the SKL<ul> <li>log that event</li> </ul> </li> <li>obtain information about the kernel from SLRT provided by a bootloader, most    notably:<ul> <li>kernel location</li> <li>kernel size</li> <li>entry point</li> </ul> </li> <li>extend PCR17 with the hash of the kernel<ul> <li>log that event</li> </ul> </li> <li>set CPU registers according to the kernel boot protocol</li> <li>jump to the entry point of kernel</li> </ol>"},{"location":"blueprints/AMD_Secure_Kernel_Loader/#things-that-yet-have-to-be-implemented","title":"Things that yet have to be implemented","text":""},{"location":"blueprints/AMD_Secure_Kernel_Loader/#dma-protection-must-be-extended-to-cover-any-additional-code-and-data","title":"DMA protection must be extended to cover any additional code and data","text":"<p>This includes mainly kernel and its configuration data passed from a bootloader, to a lesser extend also modules (kernel could set the protections for modules, it doesn't have to be done by SKL). As of now, it is impossible to do this securely.</p> <p>AMD APM Vol 2 states that it should be done with DEV (Device Exclusion Vector), but that is no longer implemented on new CPUs, except for initial SLB protection (starting with Family 17h, even that protection is handled differently).</p> <p>DEV was surpassed by the IOMMU. It is much more capable than DEV, but it also requires more data and code to set up. Those are not atomic operations, data must be first written to memory by the CPU, then CPU sends information to the IOMMU that it can parse that data, and only then the IOMMU actually reads that memory. A rogue device could potentially modify that data in the meantime, so it all should happen in the protected part of the memory.</p> <p>The issue is that IOMMU is also treated as a device, so it cannot access the memory protected by the DEV (or what's left of it). There are two possible options, both of which result in window of opportunity for unauthorized change of the memory:</p> <ul> <li>turn off the SLB protection before sending commands to the IOMMU</li> <li>build IOMMU structures outside of SLB</li> </ul> <p>The second approach requires also that the space for those structures is reserved and that SKL knows about its location.</p>"},{"location":"blueprints/AMD_Secure_Kernel_Loader/#build-options","title":"Build options","text":"<p>There are 3 configurable options, specified as command line parameters for <code>make</code>. All of them are disabled by default, they can be enabled by running <code>make &lt;opt&gt;=&lt;val&gt;</code>, where <code>&lt;opt&gt;</code> is one of the flags listed below. Note that between builds with different sets of options you must run <code>make clean</code>.</p> <ul> <li><code>LTO</code> - link time optimizations. Generally reduces the size of resulting   binary and execution time, but the exact difference is hard to predict.   Possible values: <code>n</code> (default), <code>y</code>.</li> <li><code>BITS</code> - choose between 64b and 32b mode for SKL. 32b mode saves 7*4 KB by   not producing paging tables, but due to lower number of available registers,   the code itself is about 0.5 KB larger, so net gain is just under 28 KB.   Possible values: <code>64</code> (default), <code>32</code>.</li> <li><code>DEBUG</code> - enable debug output on serial port (0x3f8). Increases the size by   about 1.3 KB. Possible values: <code>n</code> (default), <code>y</code>.</li> </ul>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/","title":"PoC: coreboot with payload started through DRTM (AMD)","text":"<p>This document uses an old version of SKL (branch drtm_payload). The instructions might not work for the newest versions.</p> <p>This proof of concept shows how TrenchBoot can be used to start coreboot payload. One of use cases may be to root chain of trust in hardware on platforms that don't support SRTM, or require proprietary tools and/or documentation that isn't publicly available.</p> <p>PC Engines apu2 platform is used in this PoC. Software stack consists of:</p> <ul> <li>coreboot,</li> <li>SKL,</li> <li>Tianocore edk2 payload.</li> </ul>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/#modifications-done-to-support-this-poc","title":"Modifications done to support this PoC","text":""},{"location":"blueprints/AMD_coreboot_DRTM_payload/#coreboot","title":"coreboot","text":"<ul> <li>Build system now includes SKL<ul> <li>Added under <code>payloads</code> directory, perhaps this is not a proper place for it</li> <li>Enabled through <code>Chipset/Launch DRTM payload before the real one</code> in config, available only for enabled platforms (depends on <code>CPU_AMD_PI</code>)</li> </ul> </li> <li>Enabled SMMSTORE<ul> <li>256KB of append only storage for UEFI authenticated variables</li> </ul> </li> <li>IOMMU is always enabled if DRTM payload is used<ul> <li>Enforced on mainboard level due to specific implementation of runtime configuration options</li> </ul> </li> <li>Loading and creating boot information tags for SKL<ul> <li>Code is built only for <code>CPU_AMD_PI</code> - CPU family 16h</li> <li>Probably could be make to work on other AMD platforms with minimal changes</li> </ul> </li> </ul>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/#skl","title":"SKL","text":"<ul> <li>Support for simple payload - just base, size, entry point and argument:</li> </ul> <pre><code>struct skl_tag_boot_simple_payload {\n    struct skl_tag_hdr hdr;\n    u32 base;\n    u32 size;\n    u32 entry;\n    u32 arg;\n} __packed;\n</code></pre>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/#tianocore","title":"Tianocore","text":"<ul> <li>SKINIT driver - discover if SKINIT was used, set GIF in that case<ul> <li>Performed early in DXE because other drivers (including SMMSTORE initialization) require enabled interrupts</li> </ul> </li> <li>IOMMU driver - enable DMA access for devices that require and request it<ul> <li>Heavily used by drivers to access storage (USB, AHCI)</li> <li>Uses <code>EDKII_IOMMU_PROTOCOL</code></li> <li>Many simplifications done, e.g. no differentiation between read and write permissions, no proper unmapping of device page tables, every invalidation uses <code>INVALIDATE_IOMMU_ALL</code> when smaller, targeted flushing would suffice</li> </ul> </li> </ul>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/#todos","title":"TODOs","text":"<ul> <li>(coreboot) information about DRTM TPM log location isn't passed to SKL</li> <li>(coreboot) SKL hash(es) aren't passed to SKL</li> <li>(SKL?) SMM is not measured</li> <li>(UEFI) APs are not started securely (i.e. without INIT) yet</li> <li>(UEFI) Tables exposed by coreboot (ACPI, SMBIOS) are not measured</li> <li>(UEFI) Polishing of IOMMU driver</li> </ul>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/#building","title":"Building","text":"<p>Clone coreboot repository, checkout appropriate branch and clone submodules:</p> <pre><code>$ git clone https://github.com/pcengines/coreboot.git\n$ cd coreboot\n$ git checkout drtm_payload\n$ git submodule update --init --checkout\n</code></pre> <p>Build using <code>coreboot-sdk</code> container:</p> <pre><code>$ docker run --rm -it -v $PWD:/home/coreboot/coreboot \\\n  -w /home/coreboot/coreboot -e USER_ID=$USER_ID -e GROUP_ID=$GROUP_ID \\\n  coreboot/coreboot-sdk:0ad5fbd48d /bin/bash\n$ cp configs/config.pcengines_apu2_drtm_payload .config\n$ make olddefconfig\n$ make\n</code></pre> <p>This should produce <code>build/coreboot.rom</code> that is to be flashed into apu2. Make sure you have a way of recovering through external flashing.</p> <p>Note that first boot takes few seconds to initialize SMMSTORE area, for release builds this results in pause after <code>skl_main() is about to exit</code>, before any output from UEFI appears. Do not be alarmed by this.</p>"},{"location":"blueprints/AMD_coreboot_DRTM_payload/#issues","title":"Issues","text":"<ul> <li>(UEFI) Support for AuthenticatedVariables is not discovered</li> <li>(UEFI) TPM driver returns error</li> </ul>"},{"location":"blueprints/Linux_Late_Launch/","title":"Linux Late Launch Kernel","text":""},{"location":"blueprints/Linux_Late_Launch/#summary","title":"Summary","text":"<p>The Linux kernel will be extended to make it function as the late launch kernel for both AMD (Secure Loader) and Intel TXT (Measured Launch Environment).</p>"},{"location":"blueprints/Linux_Late_Launch/#background","title":"Background","text":"<p>The late launch process provides a means to measure a target execution environment and then jump into the environment as presribed by the CPU's late launch protocol. This process provides a means by which to a establish a hardware-based Root of Trust for Measurement (RTM). The implementation here will provide a means to launch the Linux kernel as an RTM environment to enable building trust in a platform's launch.</p>"},{"location":"blueprints/Linux_Late_Launch/#approach","title":"Approach","text":"<p>A preliminary approach is as follows, * Create a late-launch landing zone (LZ) in 64k real code section of Linux    kernel header     - Sanitize any CPU state passed through late launch     - Verify LZ signature with pubkey     - Verify measurement from LZ signature against CRTM     - (AMD) Create/Setup TPM Event log     - Extend hash of pubkey into PCR 18, record in event log         * This aligns to TXT's DA scheme     - Parse Linux header to detect relevant details about kernel     - DEV/DMAR protect remainder of Linux kernel     - Extend hash of Linux kernel into PCR 17, record in event log     - Prepare and then handoff to Linux kernel proper         * Need to support Legacy/CSM and UEFI environments * Add a new start/launch path to Linux kernel     - Secure rendezvous APUs     - Process system state passed up from LZ         * e.g. memory map, etc.     - Setup Linux state for handover to mainline start up     - Jump into mainline start up</p>"},{"location":"blueprints/Measured_Secure_Boot/","title":"Measured Secure Boot","text":""},{"location":"blueprints/Measured_Secure_Boot/#purpose","title":"Purpose","text":"<p>To build a Measured Secure Boot (MSB) implementation that uses a hardware based Root of Trust for Measurement (RTM) from which to build a Root of Trust for Verification (RTV).</p>"},{"location":"blueprints/Measured_Secure_Boot/#background","title":"Background","text":"<p>To date the only supported Late Launch environment is the tboot project which is maintained by Intel for their Intel TXT capability. While tboot provides a complete capability, it is limited and has a number of deficiencies. While it would be possible to build a Measured Secure Boot solution around tboot, it will still be limited in comparison to approach provided by this blueprint.</p> <p>Before detailing the approach and the improvements it provides, it is good to understand how the tboot environment works. Before tboot can run, it must be loaded into memory along with the target kernel it will launch into by either a legacy multiboot compliant bootloader or by an UEFI boot manager. Tboot itself is composed of two main parts, pre-launch and post-launch execution paths. Below is a top-level execution flow for tboot from boot loader/manager to the trusted kernel that will be given control.</p> <pre><code>                        |--          tboot             --|\nboot ldr/mngr --load--&gt; pre-launch --SENTER--&gt; post-launch --launch--&gt; trusted kernel\n</code></pre> <p>In terms of integrity policy, tboot policy can only be used to measure and verify any multiboot modules loaded by the boot loader/manager. Typically tboot policy is used in one of two manners, enforcing and non-enforcing. In both cases the policy is used to control what tboot will measure and which PCRs those measurements are stored. When an enforcing policy is in place, the measurements are compared with values populated in the policy and will take a selected action when the measurements do not match. With a non-enforcing policy, measurement comparison is not done and it is left to the trusted kernel to take action on the measurements. This means if advanced actions other than measurement verification is desired, then the trusted kernel must be aware and made to take the actions.</p>"},{"location":"blueprints/Measured_Secure_Boot/#approach","title":"Approach","text":"<p>The x86 Late Launch capability will be used to establish an RTM using a Dynamic Root of Trust Measurement (DRTM) that will include the device owner's RSA public key. The Late Launch will start a TrenchBoot Security Engine (TSE) that is capable of simple measurement verification similar to tboot, but will be able to do advance actions such as a KMIP attestation for device encryption key.</p> <p>MSB will consist of an enhancement to the GNU GRUB bootloader (grub), an extended Linux kernel, and the uroot initramfs environment. The enhancement to grub will be to add TPM 1.2/2.0 support along with relocators for AMD and Intel Late Launch instructions. The Linux kernel will be extend to function as a post-launch kernel that will run the TSE. Details for each of these are documented in their own respective blueprints. Finally, below is the execution flow for MSB for comparison with tboot's execution flow above.</p> <pre><code>grub --SENTER/SKINIT--&gt; Linux/TSE --kexec--&gt; trusted kernel\n</code></pre>"},{"location":"blueprints/SLRT/","title":"Secure Launch Resource Table","text":""},{"location":"blueprints/SLRT/#summary","title":"Summary","text":"<p>SLRT is a data format whose purpose is to describe Late Launch related information and pass it from a bootloader to DCE and then to DLME.  As SLRT is being processed it can even be updated in place.</p> <p>The format is defined by Secure Launch Specification.</p>"},{"location":"blueprints/SLRT/#background","title":"Background","text":"<p>Intel TXT and AMD SKINIT follow very different approaches: while TXT has a dedicated register space and extensive data structures exposing necessary information to DCE and DLME, SKINIT is a bare mechanism which leaves all the details to an implementation.  This leaves an implementation that wants to support both DRTM solutions with two main choices:</p> <ul> <li>handle each kind of DRTM in its own specific way</li> <li>come up with a way to mostly unify different DRTMs and build code around that</li> </ul> <p>SLRT is the result of choosing the latter.</p>"},{"location":"blueprints/SLRT/#approach","title":"Approach","text":"<p>SLR table is stored sequentially in physical memory and can be described with an address pointing at its start.</p> <p>Fields are naturally aligned up to 64 bits (so 128-bit data would be aligned to 64 bits as well).</p> <p>Most of the entries and their fields are generic enough to apply to multiple current and possibly some future implementations, although some fields might not be strictly necessary in some cases.</p> <p>Platform- and architecture-specific data are contained in dedicated entries, so that only relevant information needs to be specified in any given environment.</p> <p>The SLRT is prepared by a bootloader and then passed down to DLE and DLME in a way which depends on a given platform.</p>"},{"location":"blueprints/TXT_Grub_Late_Launch/","title":"TXT Grub Late Launcher","text":""},{"location":"blueprints/TXT_Grub_Late_Launch/#purpose","title":"Purpose","text":"<p>The intent of this project is to extend Grub with the ability to call the Intel SENTER instruction.</p>"},{"location":"blueprints/TXT_Grub_Late_Launch/#background","title":"Background","text":"<p>The Intel SENTER instruction is a means to initiate a \"late launch\" that establishes a Dynamic Root of Trust Measurement (DRTM). The instruction call requires the system to be in a specific state as enumerated below,</p>"},{"location":"blueprints/TXT_Grub_Late_Launch/#approach","title":"Approach","text":"<p>Grub will be extended with the following capabilities,</p> <ul> <li>A late launch loader that will,<ol> <li>verify SENTER is supported</li> <li>load ACM and verify it matches platform</li> <li>build pagetable for MLE</li> <li>set types of cache as required by TXT</li> <li>enable native FPU error reporting</li> <li>verify no machine check in progress</li> <li>parse GETSEC[PARAMETERS]</li> <li>clear machine check registers</li> <li>allocate and fill Secure Launch Resource Table</li> </ol> </li> <li>An SENTER relocator that will,<ol> <li>set protected mode</li> <li>set registers as required by SENTER</li> <li>execute GETSEC[SENTER] as final instruction</li> </ol> </li> </ul>"},{"location":"blueprints/Xen_Late_Launch/","title":"Xen Late Launch Hypervisor","text":""},{"location":"blueprints/Xen_Late_Launch/#summary","title":"Summary","text":"<p>Xen hypervisor was extended to make it function as the late launch hypervisor for both AMD SKINIT and Intel TXT.\u00a0 The changes have not yet been upstreamed and currently target packages for Qubes OS.</p>"},{"location":"blueprints/Xen_Late_Launch/#background","title":"Background","text":"<p>The late launch process provides means to measure a target execution environment as prescribed by the CPU's late launch protocol before jumping into the environment. Thereby establishing a hardware-based Root of Trust for Measurement\u00a0(RTM).</p>"},{"location":"blueprints/Xen_Late_Launch/#approach","title":"Approach","text":"<p>File format changes:</p> <ul> <li>Added an MLE header\u00a0(defined for Intel TXT but usable on AMD where DCE is     controlled by us) to provide basic information to the bootloader including     an entry point</li> <li>Added a new entry point specific for the late launch to know how Xen was     started and be able to change behaviour based on that knowledge</li> </ul> <p>Control flow changes:</p> <ol> <li>Start Xen from GRUB2 via Multiboot2 protocol but through the entry point     from MLE header</li> <li>Figure out location of SLRT and MBI:<ul> <li>[TXT] Extract addresses from OS2MLE structure</li> <li>[SKINIT] Addresses are available in <code>%EBP</code> and <code>%EBX</code> registers respectively</li> </ul> </li> <li>[TXT] Verify that PMR ranges are sane and provide protections for all     involved components</li> <li>Reserve memory to protect it from being overwritten:<ul> <li>memory range used by TPM MMIO</li> <li>[TXT] memory occupied by TXT heap and ACM</li> <li>[SKINIT] memory occupied by SLB</li> </ul> </li> <li>[TXT] Restore pre-RTM values of MTRRs</li> <li>Measure MBI</li> <li>Process DRTM policy from SLRT\u00a0(e.g., parts of SLRT, Linux kernel, its     parameters, memory map, initrd)</li> </ol> <p>Other code modifications:</p> <ul> <li>Add TXT-specific way of waking up APs</li> <li>Perform parallel startup of APs, because TXT always starts them     simultaneously</li> <li>Add TPM driver and update TPM event log when PCRs are extended</li> </ul>"},{"location":"dev-docs/","title":"TrenchBoot Documentation","text":"<p>Here you will find documentation for building and deploying security engine components.</p> <p>{nav}</p>"},{"location":"dev-docs/CONTRIBUTING/","title":"Contributing to TrenchBoot","text":"<p>We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's:</p> <ul> <li>Reporting a bug</li> <li>Discussing the current state of the code</li> <li>Submitting a fix</li> <li>Proposing new features</li> <li>Becoming a maintainer</li> </ul>"},{"location":"dev-docs/CONTRIBUTING/#project-structure","title":"Project Structure","text":"<p>The functionality being developed under TrenchBoot are cross-cutting capabilities that span multiple open source projects.  The role of TrenchBoot is to function as both a development as well as a cross-project integration project. As such it maintains a set of repository clones of upstream project(s) that TrenchBoot conducts development within.</p>"},{"location":"dev-docs/CONTRIBUTING/#upstream-repository","title":"Upstream Repository","text":"<p>For each upstream repository within TrenchBoot will have at least one maintainer. The maintainer(s) will have merge permissions and responsible for maintaining adherence to upstream practices. When necessary, they are responsible for maintaining out-of-tree capabilities developed by TrenchBoot.</p>"},{"location":"dev-docs/CONTRIBUTING/#upstream-focus","title":"Upstream Focus","text":"<p>One of the primary objectives for TrenchBoot is to deliver interoperable launch integrity capabilities to existing open source projects involved with the system boot cycle. Under this objective, all development against an upstream project must comply with upstream coding style and strive to minimize disruption/breakage of upstream capabilities.</p>"},{"location":"dev-docs/CONTRIBUTING/#out-of-tree-maintenance","title":"Out of Tree Maintenance","text":"<p>There may be a case that a TrenchBoot capability may encounter a slow adoption by an upstream project which results in multiple upstream releases without the capability merged. As such the capability in question must be kept in sync with upstream changes. While this situation is not desired, it is likely to occur and will be the responsibility of the respective TrenchBoot maintainer(s).</p>"},{"location":"dev-docs/CONTRIBUTING/#branch-naming-convention","title":"Branch naming convention","text":"<p>In the case described above, a dedicated branch may be created with the name in form <code>feature-version</code>, where <code>feature</code> is a short and consistent name describing what this branch implements, and <code>version</code> specifies the point in time at which the branch was created from upstream, e.g. as a date or a release tag. It may be optionally followed by a version of set of commits.</p> <p>In case the changes must be synchronized between two or more projects, the feature name and local version must follow the same convention in all involved repositories. linux-sl-master-9-12-24-v11 and grub-sl-2.12-v11 is an example of such synchronized pair of branches, where their bases are described as <code>master-9-12-24</code> (head of <code>master</code> as of September 12th, 2024) and <code>2.12</code> (tag marking an upstream release) respectively.</p>"},{"location":"dev-docs/CONTRIBUTING/#trenchboot-original-repositories","title":"TrenchBoot Original Repositories","text":"<p>While the focus is on delivering capabilities into upstream projects, it is possible that a new or derivative code base may result to fulfill a role in a cross-cutting capability. The maintainer(s) for these code bases will be responsible for establishing coding styles and licensing that ensure compliance with all other TrenchBoot relevant projects.</p>"},{"location":"dev-docs/CONTRIBUTING/#development","title":"Development","text":"<p>We use GitHub to host the project, to include tracking issues and feature requests, as well as accept pull requests.</p>"},{"location":"dev-docs/CONTRIBUTING/#development-flow-overview","title":"Development Flow Overview","text":"<p>Pull requests are the best way to propose changes to the project (we use Github Flow). We actively welcome your pull requests:</p> <ol> <li>Fork the repo and create your branch from <code>master</code>.<ul> <li>If it is heavily outdated, use upstream <code>master</code> instead and ask the maintainer to update the repository when issuing the pull request.</li> <li>If your change is specific to a feature that isn't present on <code>master</code>, use the latest branch with that feature instead.</li> </ul> </li> <li>If you've added code that should be tested, add tests.</li> <li>If you've changed APIs, update the documentation.</li> <li>Ensure the test suite passes.</li> <li>Make sure your code lints.</li> <li>Issue that pull request!</li> </ol>"},{"location":"dev-docs/CONTRIBUTING/#contribution-licensing","title":"Contribution Licensing","text":"<p>TrenchBoot is a cross-community integration project consisting of project repositories along with upstream project repositories. All contributions to a repository are made under the license that covers all work in that repository.</p>"},{"location":"dev-docs/CONTRIBUTING/#issue-tracking","title":"Issue Tracking","text":"<p>Report issues, e.g. bugs, feature requests, etc., using Github's issues</p> <p>Great Issues tend to have:</p> <ul> <li>A quick summary and/or background</li> <li>For bug reports include:<ul> <li>Steps to reproduce for bugs<ul> <li>Be specific!</li> <li>Give sample code if you can.</li> </ul> </li> <li>What you expected would happen</li> <li>What actually happens</li> <li>Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)</li> </ul> </li> <li>For feature requests include:<ul> <li>An outline of how the feature would work</li> <li>Any dependencies the feature would require</li> <li>The benefit the feature will provide</li> </ul> </li> </ul>"},{"location":"dev-docs/CONTRIBUTING/#coding-style","title":"Coding Style","text":"<p>Markdown documents should be formatted to 80 columns to the extent possible. Exception to the 80 column is when column limitation breaks markdown rendering.</p> <p>Contributions targeting upstream project repositories will follow the upstream project's coding style rules.</p>"},{"location":"dev-docs/CONTRIBUTING/#license","title":"License","text":"<p>This work is licensed under a Creative Commons Attribution 4.0 International License.</p> <p>By contributing you agree that your contributions will be licensed under the Creative Commons Attribution 4.0 International License. Feel free to contact the maintainers if that's a concern.</p>"},{"location":"dev-docs/CONTRIBUTING/#contacting-maintainers","title":"Contacting Maintainers","text":"<p>TrenchBoot is maintained by:</p> <ul> <li>Daniel P. Smith dpsmith@apertussolutions.com</li> </ul>"},{"location":"dev-docs/CONTRIBUTING/#references","title":"References","text":"<p>This document was adapted from the this open-source contribution template</p>"},{"location":"dev-docs/DevelopersGuide/","title":"Developers Guide","text":"<p>TrenchBoot is a framework that provides for users the ability to select the kernel and security engine components appropriate for their target environment. This developers guide focuses on the software components of TrenchBoot and the build system used to compose TrenchBoot launchable images.</p>"},{"location":"dev-docs/DevelopersGuide/#trenchboot-linuxu-root-configuration","title":"TrenchBoot Linux/u-root Configuration","text":"<p>A TrenchBoot launchable image consists of a TrenchBoot Linux kernel with a TrenchBoot u-root initramfs embedded within the image. When building for a target, the boot capabilities and BITs that will be supported will result in different launchable images. The diagram below provides a simple visual depiction of this setup.</p> <p></p> <p>As a result of the build process, one or more kernel images may be generated. By convention these kernels will be labeled as such:</p> <ul> <li>bzImage.uefi: An image built to be launch by a UEFI environment</li> <li>bzImage.skinit: An image built to be launched with AMD's SKINIT instruction</li> <li>bzImage.senter: An image built to be launched with Intel's SENTER instruction</li> <li>bzImage.bios: An image build to be launched by a legacy BIOS boot loader</li> </ul>"},{"location":"dev-docs/Late_Launch_Overview/","title":"Introduction to Late Launch","text":"<p>This is an introduction of the \"Late Launch\" process on x86-based systems to establish a Dynamic Root of Trust for Measurement (DRTM). Late Launch is another name for a Dynamic Launch of a system for x86-based platforms. As such it is good to understand the difference between a Static Launch and a Dynamic Launch on x86 platforms.  For x86 the fixed location used for a Static Launch is known as the reset vector which maps to SPI flash storage. A Dynamic Launch is achieved with a light-weight processor bootstrap initiated through a CPU instruction. For Intel the capability that provides this is called TXT and is initiated with the GETSEC[SENTER], summarily SENTER, instruction. For AMD it is considered part of AMD's secure virtualization (AMD-V) and is initiated with the SKINIT instruction.</p> <p>An important function of x86 Late Launch CPU instructions is that they \"measure\" the execution code provided for the launch. This action of \"measure\" is accomplished by taking a cryptographic hash using an algorithm supported by the TCG's Trusted Platform Module (TPM) so that it may store the measurement within one of the TPM's Platform Configuration Registers (PCR). This initial measurement, referred to as the Core Root of Trust Measurement (CRTM), is the trust anchor for the DRTM.</p> <p>While the Intel and AMD implementations of Late Launch both achieve a DRTM, how their implementations arrive at a DRTM are significantly different. As a result each will be addressed separately.</p>"},{"location":"dev-docs/Late_Launch_Overview/#intel-trusted-execution-technology-txt","title":"Intel Trusted eXecution Technology (TXT)","text":"<p>For TXT, Intel set about a holistic approach<sup>1</sup> that introduced the Safer Mode Extensions (SMX) instruction set. As a result TXT provides for advanced security capabilities such as measuring System Management Mode (SMM) when an SMI Transfer Monitor (STM) is in place. The TXT process is built around the SINIT Authenticated Code Module (ACM) and a Measured Launch Environment (MLE). The ACM is a binary provided by Intel and the MLE is a software solution typically provided by the OS provider. Details about the ACM and the MLE are explained in the \"Intel TXT Measured Launch Environment Developer's Guide\"<sup>2</sup>.</p>"},{"location":"dev-docs/Late_Launch_Overview/#senter-procedure","title":"SENTER Procedure","text":"<p>From the moment when the SENTER instruction is invoked until execution control is handed to the MLE, a series of computations are completed by the CPU and then by the ACM to generate integrity assertions in the form of measurements about the platform environment as well as the MLE that will be given control. Details about the CPU's role in the launch can be found in the Intel Software Developer's Manual (SDM) under Vol. 2D 6.2.3 para 3 and 6.3 GETSEC[SENTER]<sup>3</sup>. The primary role for the CPU is to establish an environment that minimizes the ability of external tampering and taking the CRTM used for the DRTM. Below is an outline of the internal steps that the CPU takes when the SENTER instruction is initial invoked,</p> <ol> <li>Inhibit processor response to external events: INIT, A20M, NMI, and SMI.</li> <li>Establish and check the location and size of the authenticated code module    to be executed by the ILP.</li> <li>Check for the existence of an Intel\u00ae TXT-capable chipset.</li> <li>Verify the current power management configuration is acceptable.</li> <li>Broadcast a message to enable protection of memory and I/O from the    activities of other processor agents.</li> <li>Load the designated AC module into the authenticated code execution area.</li> <li>Isolate the content of the authenticated code execution area from further    state modification by external agents.</li> <li>Authenticate the AC module.</li> <li>Updated the Trusted Platform Module (TPM) with the authenticated code    module's hash.</li> <li>Initialize processor state based on the authenticated code module header     information.</li> <li>Unlock the Intel\u00ae TXT-capable chipset private configuration register space     and TPM locality 3 space.</li> <li>Begin execution in the authenticated code module at the defined entry point.</li> </ol>"},{"location":"dev-docs/Late_Launch_Overview/#txt-acm","title":"TXT ACM","text":"<p>The ACM is the portion that is responsible for implementing the advanced security capabilities provided by TXT. To achieve this, the CPU provides a highly privileged execution mode that is capable of inspecting System Management Mode (SMM) memory (SMRAM), this is needed to allow the measurement of the STI. As a result it is highly important that only authorized code is allowed to execute in this mode. This is handled in step 8., the authentication of the ACM. The details of this process can be found in section A.1.2 of the MLE Developers Guide.<sup>2</sup> The ACM is entrusted with a series of responsibilities, ones of particular note are IOMMU protecting the MLE, measuring the MLE, and the enforcement of the Launch Control Policy (LCP).</p>"},{"location":"dev-docs/Late_Launch_Overview/#launch-control-policy","title":"Launch Control Policy","text":"<p>One of the capabilities provided by the ACM is the LCP Engine. The LCP is a rarely used mechanism to enforce that a known environment is being used. Within the ACM is an LCP engine that will look for a LCP in a designated TPM NVRAM address. The LCP allows for defining expected values for TPM PCRs and/or the expected hash value of the MLE. If a policy check fails, then the LCP Policy Engine will trigger the ACM to error exit from the SENTER instruction.</p>"},{"location":"dev-docs/Late_Launch_Overview/#measured-launch-environment","title":"Measured Launch Environment","text":"<p>The final component in the Intel TXT process is the MLE, a software component that is responsible for the secure setup and execution of the target runtime. As the ACM conducted a transitive trust extension to the MLE, the MLE should similarly conduct a transitive trust extension to bring the target runtime within the SMX trust boundary by protecting the runtime's memory from tampering, measuring the runtime, and optionally enforcing policy to ensure only authorized runtimes are allowed to execute.</p>"},{"location":"dev-docs/Late_Launch_Overview/#amd-secure-startup","title":"AMD Secure Startup","text":"<p>The AMD approach is a simpler one that allows more control over code executed by the SKINIT instruction, to include environment setup and measurements, but unlike Intel's ACM, execution is limited to the same accesses as superprivileged mode. This means it is not possible to obtain a measurement of SMRAM at the time of the late launch. Therefore the trust boundary of SKINIT still bound to the SRTM. To use the Secure Startup capability, a Secure Loader (SL) image must be loaded and passed to SKINIT. Details about building an SL and calling the SKINIT instruction can be found in the AMD ARM64 Architecture Programmer's Manual, Volume 2<sup>4</sup>.</p>"},{"location":"dev-docs/Late_Launch_Overview/#skinit-procedure","title":"SKINIT Procedure","text":"<p>When the SKINIT instruction is executed, the base address for the SL is passed in the EAX register. The CPU will then execute the following sequence,</p> <ol> <li>Reinitialize the processor state similar to INIT signal.</li> <li>Enter 32bit protected mode with paging disabled.</li> <li>Clear all general purpose registers except,<ul> <li>EAX: start address of SL,</li> <li>EDX: CPU model, family, and stepping.</li> </ul> </li> <li>Secures registers,<ul> <li>Most MSRs retain their values (except those which might compromise SVM   protections),</li> <li>EFER MSR is cleared,</li> <li>setting DPD, R_INIT and DIS_A20M flags in the VM_CR register   unconditionally to 1.</li> </ul> </li> <li>Page align EAX and use as the start address for 64KBytes of DEV protection.</li> <li>Securely initializes AP(s),<ul> <li>clears Global Interrupt Flag (GIF),</li> <li>setting DPD, R_INIT and DIS_A20M flags in the VM_CR register.</li> </ul> </li> <li>Transmit SL image to TPM for hash, any failure will trigger SKINIT failure.</li> <li>Clear the GIF on the BSP which disables all interrupts, including NMI, SMI,    and INIT.</li> <li>Update ESP to point at SL stack (SLB base + 65536).</li> <li>Add SL entry offset to SL base and jump to that address.</li> </ol>"},{"location":"dev-docs/Late_Launch_Overview/#secure-loader","title":"Secure Loader","text":"<p>In the AMD world, the initial code executed by the SKINIT instruction is the Secure Loader (SL). The SL is an Owner provided code base that is responsible for securely initializing the system and handover to a Security Kernel (SK). The SL must meet three primary conditions,</p> <ol> <li>SL image's first two words (each 16bit) contain the entry point offset and    size of measured part of the image (code and initialized data).</li> <li>SL code and data (including stack) must be less than 64KBytes.</li> <li>SL image must be loaded page aligned.</li> </ol> <p>Upon execution, the SL is responsible for protecting the remainder of the execution environment through measurement and memory protection of the SK to which it will be handing over control.</p>"},{"location":"dev-docs/Late_Launch_Overview/#security-kernel","title":"Security Kernel","text":"<p>For AMD Secure Startup the last component is the SK. The SK can be an intermediate kernel or a target runtime kernel. The situation that drives the need for an intermediate kernel is for solutions that need to do more complex security verification and/or hand-off to target runtime kernel that cannot be implemented in less than 64Kbytes.</p>"},{"location":"dev-docs/Late_Launch_Overview/#foot-notes","title":"Foot Notes","text":"<ol> <li> <p>Grawrock, D. (2006). The Intel safer computing initiative. Hillsboro, Or.: Intel Press.  https://books.google.com/books?id=WmGjSgAACAAJ \u21a9</p> </li> <li> <p>Intel\u00ae Trusted Execution Technology (Intel\u00ae TXT) Software Development Guide:    Measured Launched Environment Developer\u2019s Guide https://www.intel.com/content/dam/www/public/us/en/documents/guides/intel-txt-software-development-guide.pdf \u21a9\u21a9</p> </li> <li> <p>Intel\u00ae 64 and IA-32 Architectures Software Developer\u2019s Manual,    Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4 https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf \u21a9</p> </li> <li> <p>AMD64 Architecture Programmer\u2019s Manual Volume 2: System Programming https://www.amd.com/system/files/TechDocs/24593.pdf \u21a9</p> </li> </ol>"},{"location":"dev-docs/code/","title":"Code Repositories","text":"<p>Core project repositories for TrenchBoot project.</p> <ul> <li>GRUB SecureLaunch for Intel<ul> <li>Latest snapshot of Intel TXT support for GRUB</li> </ul> </li> <li>GRUB SecureLaunch for AMD<ul> <li>Latest snapshot of AMD SKINIT support for GRUB</li> </ul> </li> <li>Linux 5.13 SecureLaunch for Intel and AMD<ul> <li>Latest snapshot Linux Secure Launch for Intel &amp; AMD</li> </ul> </li> <li>Secure Kernel Loader<ul> <li>Implementation of the AMD Secure Loader specification for SKINIT</li> </ul> </li> <li>Tools for Linux SecureLaunch<ul> <li>A suite of tools for development, debugging, and launch status.</li> </ul> </li> </ul>"},{"location":"references/","title":"References","text":"<p>Here you will find reference knowledge explaining concepts and theory behind TrenchBoot.</p> <p>{nav}</p>"},{"location":"specifications/","title":"Specifications","text":"<p>TrenchBoot developed specifications.</p> <p>{nav}</p>"},{"location":"specifications/Secure_Launch/","title":"Secure Launch Specification","text":"<p>The Secure Launch specification describes a common approach for implementing Dynamic Launch. This specification is to enable any conforming bootloader to be able to initiate a Dynamic Launch of any conforming OS kernel.</p> <p></p>"},{"location":"steering-committee/","title":"Steering Committee Meetings","text":"<p>Here you will find the meeting minutes from the Steering Committee and Community Meetings.</p> <p>{nav}</p>"},{"location":"steering-committee/Community-Meeting-June17-2021/","title":"Community Meeting June 17 2021","text":""},{"location":"steering-committee/Community-Meeting-June17-2021/#agendanotes","title":"Agenda/Notes","text":"<ul> <li> <p>Outreach and Engagement</p> <ul> <li> <p>TrenchBoot Developers Forum</p> <ul> <li> <p>Determine time period and/or dates</p> <ul> <li>Piotr feels every 12 mo would be quite long<ul> <li>is six months too short to discuss things</li> <li>thinks sept. we should have something</li> <li>OSFC planned for Dec.</li> </ul> </li> <li>Rich, should do it when things get cold and are locked up<ul> <li>Do TB talks at multiple events</li> <li>We should have an internal event, but maybe make it a DRTM event</li> </ul> </li> <li>DK, LPC at end of 24Sept<ul> <li>Should have confirmation by the end of June for LPC MC</li> <li>should have slots available for TB talks</li> </ul> </li> </ul> </li> <li> <p>Select chairman to oversee planning/coordination</p> <ul> <li>Piotr we would like to help but cannot do it alone<ul> <li>will engage IBM POWER about sponsoring</li> </ul> </li> <li>Rich recommends bring the topic up at DRTM related meetings and try to find a corporate sponsor</li> </ul> </li> </ul> </li> <li> <p>TrenchBoot website</p> <ul> <li> <p>Identify content that would like to be on the site</p> <ul> <li>Piotr: coreboot is hooking to rss feeds that feed into blog<ul> <li>will look at what coreboot implementation</li> <li>will look at mkdocs setup to move TB documentation over to</li> </ul> </li> <li>DanK: will speak with a colleague, will have a response when back from vacation</li> </ul> </li> <li> <p>Discuss approach to maintenance/development</p> <ul> <li>should apply GH auto fixes</li> </ul> </li> </ul> </li> <li> <p>TrenchBoot Social Media</p> <ul> <li>Review social media accounts and strategy<ul> <li>Twitter</li> <li>LinkedIn project site/group</li> <li>Others?</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Project</p> <ul> <li> <p>Moving AMD support forward</p> <ul> <li> <p>LZ renaming</p> <ul> <li>Piotr thinks AMD should be involved in TB AMD related topics<ul> <li>we should also try to get them involved with the call</li> </ul> </li> <li>Rich, this is a public meeting, may need to have NDA meeting</li> </ul> </li> <li> <p>LZ IOMMU approach adoption</p> <ul> <li>Ross: just adopt current proposed approach as a starting place<ul> <li>yes the pitsaw card could be used</li> </ul> </li> <li>Piotr, the current approach is better than nothing<ul> <li>are there tests?</li> </ul> </li> <li>Kanth: can the pitsaw card be used to test iommu for txt, can be used for AMD</li> </ul> </li> <li> <p>DRTM log approach adoption</p> <ul> <li>Piotr: based on TCG spec<ul> <li>this is where the HCL will be useful</li> <li>can test Ross changes for linux kernel</li> <li>will work on \"legacy mode\" support</li> </ul> </li> <li>Ross: need to handle system without the ACPI table<ul> <li>can make so that the ACPI table is preferred approach then fail back to non-ACPI table</li> <li>for the LZ will need to also be made to handle non-ACPI table situation (legacy mode)</li> <li>will work on \"legacy mode\" support</li> </ul> </li> <li>Daniel: merge the PR<ul> <li>has been confirmed on pc-engines</li> </ul> </li> </ul> </li> <li> <p>iPXE support</p> <ul> <li>Piotr: submitted patches but rejected as too big<ul> <li>https://github.com/ipxe/ipxe/pull/300</li> <li>we should care about iPXE</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Upcoming v2 LKML submission</p> <ul> <li>Ross: it looks like it will be going out tomorrow (6/18/2021)</li> </ul> </li> <li> <p>GRUB submission</p> <ul> <li>Daniel K: currently working with Lukasz and will looking to submit in July<ul> <li>will be working with 3mdeb on aligning AMD changes</li> </ul> </li> </ul> </li> <li> <p>Deployment/Adoption support</p> <ul> <li> <p>TrenchBoot Hardware Compatibility List</p> <ul> <li>How to check if my hardware is supported or can be supported?<ul> <li>Piotr: resource constrained but we need something very basic<ul> <li>what all should be checked, log, pcrs, etc</li> <li>this is QubesOS HCL as an example<ul> <li>https://www.qubes-os.org/hcl/</li> </ul> </li> <li>list of hardware for people to get started with</li> </ul> </li> <li>Rich:<ul> <li>there are a lot of things that make you feel better but not gain much<ul> <li>maybe skip over that and focus on community</li> </ul> </li> <li>biggest issues will be with hardware that is not MS certified</li> <li>both OXT and Qubes HCL are not correct because every system has quirks</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>TrenchBoot Canonical Demo</p> </li> <li> <p>TrenchBoot as AEM for QubesOS</p> <ul> <li>Piotr: would be good to assist with anit-evil maid demo</li> </ul> </li> </ul> </li> <li> <p>Test automation (Kanth)</p> <ul> <li>Rich suggest this is a place for Qemu support for DRTM to enable software based testing<ul> <li>at tdf txt lead mentioned txt test suite in FWUPD</li> <li>we should get OEM testing</li> <li>could TB lead DRTM test suite development</li> <li>if there isn't one, who is willing to fund its development</li> <li>live cd is not enough, need to build a cross-community project</li> <li>this can be a theme for the DRTM event</li> </ul> </li> <li>Piotr agrees that this FWUPD testing support is desired</li> <li>Kanth, Oracle will be increasing supported platforms and would like to see automated testing/validation<ul> <li>Oracle would be interested in helping with building a DRTM test framework</li> </ul> </li> <li>Daniel K: GRUB does not have automated testing but it is in progress<ul> <li>thinks it would be quite easy to introduce tests for preamble</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Additional Topics (time permitting)</p> <ul> <li> <p>DRTM/TrenchBoot for Arm</p> <ul> <li>Stuart: Beta spec will be public by fall and possible reference implementation</li> <li>Rich: coordinate a TB event around Arm event/announcement</li> </ul> </li> <li> <p>Plan for SMM</p> <ul> <li>intel whitepaper on SMM DRTM protection</li> </ul> </li> <li> <p>Integration with FWUPD hardware security test</p> </li> </ul> </li> <li> <p>General Business</p> <ul> <li> <p>Open floor for community members</p> </li> <li> <p>Next meeting</p> <ul> <li>Piotr we missed several topics<ul> <li>discuss getting more resources</li> <li>fobnail</li> <li>testing</li> </ul> </li> <li>Rich we should not do meetings during the summer and do out-of-band discussions (chat/email)<ul> <li>perhaps use OSFC TB slack</li> </ul> </li> <li>Will be done virtually via TB slack channel</li> </ul> </li> </ul> </li> </ul>"},{"location":"theory/","title":"TrenchBoot Documentation","text":"<p>Here you will find theoretical background for TrenchBoot project, such as DRTM and its implementations, as well as design artifacts.</p> <p>{nav}</p>"},{"location":"theory/Architecture/","title":"General Architecture","text":"<p>The general execution flow for TrenchBoot is broken into three phases, Bootstrap, Intermediate, and Runtime. The Bootstrap phase primarily consists of the existing bootstrap technology, e.g. UEFI, grub, UEFI shim, etc. For TrenchBoot the bootstrap technologies that have an integrity function, referred to as a Boot Integrity Technology (BIT), are of primary interest. The Intermediate phase is that which the TrenchBoot Loader executes to establish the launch integrity of the system. The last phase is the Runtime phase and is where the target runtime, hypervisor, operating system, etc, is given control over the system.</p> <p></p>"},{"location":"theory/Architecture/#trenchboot-security-engine","title":"TrenchBoot Security Engine","text":"<p>At the heart of the TrenchBoot Loader is the TrenchBoot Security Engine.  The Security Engine is responsible for processing any evidence collected by the BITs, collecting new evidence as needed, evaluating all evidence according to a security policy, and executing appropriate enforcement actions. The components that enable this and their relationship can be seen in the top level diagram below.</p> <p></p>"},{"location":"theory/Architecture/#evidence","title":"Evidence","text":"<p>A core concept in TrenchBoot is that of evidence. For TrenchBoot, evidence is a record of an event that occurred within the system. The typical form for these records is a cryptographic hash of the system state that was the result of this event. This cryptographic hash is often referred to as a measurement.</p>"},{"location":"theory/Architecture/#boot-integrity-technology","title":"Boot Integrity Technology","text":"<p>Boot Integrity Technologies (BITs) are software or hardware capabilities that are responsible for a portion of system launch. Specifically these capabilities attempt to establish and/or enforce a degree of integrity that the correct logic was used to launch the system.</p>"},{"location":"theory/Architecture/#bit-augmentation","title":"BIT Augmentation","text":"<p>There may be BITs that need to be directly or indirectly extended to enable or enhance their usage for launching a TrenchBoot environment.</p>"},{"location":"theory/Architecture/#bit-ingestion","title":"BIT Ingestion","text":"<p>A TrenchBoot Security Engine must be capable of supporting a variety of evidence formats for the various BITs supported. Translation of these various formats allows TrenchBoot to maintain normalized data structures for evidence collected. This allows the functionality in Security Processor to only have to reason about normalized data without specialized logic for different data formats.</p>"},{"location":"theory/Architecture/#security-processor","title":"Security Processor","text":"<p>At the heart of a TrenchBoot Security Engine is the Security Processor. The Security Processor consist of the logical components that will consume a launch policy and take one or more actions to evaluate the state of the system necessary to enforce the policy. This may include, but is not limited to, collecting additional evidence, making attestation assertions, retrieving encryption keys, and file/block/drive decryption. The enforcement of the security policy will result in a full, partial, or failed boot of the system.</p>"},{"location":"theory/Architecture/#launchhand-off","title":"Launch/Hand Off","text":"<p>Ultimately TrenchBoot's responsibility is to launch a target environment. As such it must be equipped with the various ways required to launch those target environments.</p>"},{"location":"theory/Glossary/","title":"Glossary","text":"<p>Provided are definitions of terms used throughout TrenchBoot's documents and designs to encourage a common vocabulary and understanding.</p>"},{"location":"theory/Glossary/#amd-skinit","title":"AMD SKINIT","text":"<p>AMD's implementation of Dynamic Launch. \"AMD Secure Startup with SKINIT\" is the longer version.</p>"},{"location":"theory/Glossary/#authenticated-code-module-acm","title":"Authenticated Code Module (ACM)","text":"<p>A proprietary software component built and signed by Intel that is used as a DCE for Intel TXT. Also referred to as \"SINIT\", \"SINIT ACM\" or \"SINIT AC module\".</p>"},{"location":"theory/Glossary/#dynamic-configuration-environment-dce","title":"Dynamic Configuration Environment (DCE)","text":"<p>A software component like ACM or Secure Loader that is the first to run in a secure execution environment before passing control to DLME.</p>"},{"location":"theory/Glossary/#dynamic-launch-dl","title":"Dynamic Launch (DL)","text":"<p>A system launch that can be done repeatedly with the execution code able to reside at different locations in memory. This is sometimes referred to as a \"Late Launch\". This is related to dynamic RTM (D-RTM, D-CRTM, DRTM).</p>"},{"location":"theory/Glossary/#dynamic-launch-event-dle","title":"Dynamic Launch Event (DLE)","text":"<p>A special instruction of a processor supporting Dynamic Launch that initiates the process (e.g., <code>GETSEC[SENTER]</code> on Intel or <code>SKINIT</code> on AMD) resulting in the execution of DCE.</p>"},{"location":"theory/Glossary/#dynamic-launch-measured-environment-dlme","title":"Dynamic Launch Measured Environment (DLME)","text":"<p>A software component (e.g., an OS or a hypervisor) that gets started by DCE. Known as MLE in case of Intel TXT.</p>"},{"location":"theory/Glossary/#explicit-trust","title":"Explicit Trust","text":"<p>When a trustor has explicitly established a degree of trust with a trustee.</p>"},{"location":"theory/Glossary/#implicit-trust","title":"Implicit Trust","text":"<p>When a trustor has relied upon a trustee to establish a degree of trust with another trustee.</p>"},{"location":"theory/Glossary/#intel-trusted-execution-technology-intel-txt","title":"Intel Trusted Execution Technology (Intel TXT)","text":"<p>Intel's implementation of Dynamic Launch.</p>"},{"location":"theory/Glossary/#measured-launched-environment-mle","title":"Measured Launched Environment (MLE)","text":"<p>A term for DLME as used by Intel TXT.</p>"},{"location":"theory/Glossary/#root-of-trust-rot","title":"Root of Trust (RoT)","text":"<p>An idempotent mechanism whereby the result is used to assert a fact about the entity it acted upon.</p>"},{"location":"theory/Glossary/#root-of-trust-for-measurement-rtm-crtm","title":"Root of Trust for Measurement (RTM, CRTM)","text":"<p>The first entity in the chain of measurements. Also called \"Core RTM\". Can be static (SRTM) or dynamic (DRTM).</p>"},{"location":"theory/Glossary/#secure-kernel-loader-skl","title":"Secure Kernel Loader (SKL)","text":"<p>Free and open source implementation of a Secure Loader for AMD Secure Startup with SKINIT.</p>"},{"location":"theory/Glossary/#secure-launch-sl-slaunch","title":"Secure Launch (SL, slaunch)","text":"<p>A specification describing a common approach for implementing Dynamic Launch.</p>"},{"location":"theory/Glossary/#secure-launch-resource-table-slrt","title":"Secure Launch Resource Table (SLRT)","text":"<p>A platform-agnostic, standard format for providing information to the DLE Handler and for passing relevant information across the DLE to be available for use by the DCE and the DLME.</p>"},{"location":"theory/Glossary/#static-launch","title":"Static Launch","text":"<p>A system launch that is a one time execution with the execution code at a fixed location in memory. This is related to static RTM (S-RTM, S-CRTM, SRTM).</p>"},{"location":"theory/Glossary/#secure-loader-sl","title":"Secure Loader (SL)","text":"<p>A user-provided binary which acts as a DCE for AMD SKINIT.</p>"},{"location":"theory/Glossary/#secure-loader-block-slb","title":"Secure Loader Block (SLB)","text":"<p>A region of memory into which Secure Loader is loaded.</p>"},{"location":"theory/Glossary/#transitive-trust","title":"Transitive Trust","text":"<p>An operation conducted by a trustor that consists of one or more mechanisms used to assess one or more facts about a trustee before allowing the trustee to be included within the trustor's trust boundary and delegated the authority to act as a trustor.</p>"},{"location":"theory/Glossary/#trust","title":"Trust","text":"<p>Assured reliance on the properties, ability, strength, or truth of an entity.</p>"},{"location":"theory/Glossary/#trust-anchor","title":"Trust Anchor","text":"<p>The result of a Root of Trust mechanism that is a fact being relied upon to assert correctness, e.g. trustworthiness.</p>"},{"location":"theory/Glossary/#trust-boundary","title":"Trust Boundary","text":"<p>A demarcation that identifies a subset of entities as those that a trustor has explicitly or implicitly established as trustworthy.</p>"},{"location":"theory/Glossary/#trustee","title":"Trustee","text":"<p>An entity that is trusted by another entity.</p>"},{"location":"theory/Glossary/#trustor","title":"Trustor","text":"<p>An entity that establishes a degree of trust of another entity.</p>"},{"location":"theory/UseCases/","title":"TrenchBoot Use Cases","text":"<p>TrenchBoot is meant to be a universal framework to enable building integrity in the launch process of systems. To relate to real world usage, it is good to have a set of use cases that explain a subset of situations where TrenchBoot is applicable and how it would work in those situations. Below are a series of use cases that are actively being investigated and/or worked on.</p>"},{"location":"theory/UseCases/#crowd-sourcing-integrity","title":"Crowd Sourcing Integrity","text":"<p>There is currently no known public authority available to verify BIOS/Firmware PCR values. TrenchBoot would like to become such an authority but there is the challenge of how to obtain all these values in a manner that provide assurance to the authenticity of the values. Crowd sourcing provides the best means to collect the largest and most diverse set of values. The challenge with crowd sourcing the values is how to establish authenticity of the values. This challenge can be overcome with a TrenchBoot based live CD that establishes an attestation identity provisioned by a TrenchBoot Attestation Certificate Authority (ACA).</p>"},{"location":"theory/UseCases/#network-attestation-launch","title":"Network Attestation Launch","text":"<p>An individual or enterprise may not want to allow a system to boot on their network unless it is running a known configuration. When TrenchBoot is installed onto a system it will work in conjunction with a TrenchBoot ACA (public or private instance) that provides a key management service. TrenchBoot will hold a portion of a Shamir Secret Sharing key with another portion held by the key management service. For the system to boot it will attest to the key management service to obtain a key fragment that will allow it to unlock the system disk.</p>"},{"location":"theory/UseCases/#travel-laptop-2fa-launch","title":"Travel Laptop 2FA Launch","text":"<p>When travelling there are times when an individual loses positive control of their device. During these times attackers can launch physical access attacks. For this configuration TrenchBoot will \"double chain wrap\" the encryption key for decrypting the system where each chain wrap correlates to an authentication factor. Working internal to external, the system drive key is encrypted with the first wrap key that is in turn encrypted with the second wrap key. The first wrap key is stored on a removable token device, e.g. YubiKey, and the second wrap key is sealed in a TPM NVRAM slot. For a system to boot it must have launched with the correct firmware and the token must be present.</p>"},{"location":"user-docs/","title":"Getting started","text":"<p>Here you will find documentation for installing and using security engine components.</p> <p>{nav}</p>"},{"location":"user-docs/QUICKSTART/","title":"Linux Quick Start Guide","text":"<p>A quick start guide to getting a Linux system running with the latest Secure Launch bits from TrenchBoot. Note that this is a bare bones document meant to help someone get up and running with Secure Launch. It does not contain detailed descriptions of all the technologies and terminology involved in doing a Secure Launch. The repository this document resides in as well as the Linux Secure Launch documentation submitted with the Linux patch sets (under Documentation/security/launch-integrity/) contain a plethora of other resources and information that can be used to understand the Secure Launch technology more broadly.</p> <p>For topics not addressed by this document, please contact TrenchBoot developers via the community site:</p> <ul> <li>Community</li> </ul>"},{"location":"user-docs/QUICKSTART/#platforms","title":"Platforms","text":"<p>The current patchset (version 11) only supports Intel TXT. AMD SKINIT support is in the works and coming soon.</p> <p>An Intel system (desktop, server, laptop) needs to be a vPro SKU in order to have TXT support available. Generally speaking, vPro systems will advertise this with a sticker somewhere on the unit. Intel TXT support usually needs to be enabled in the firmware setup program. It depends on both the TPM and VTd being enabled. The details on how to do this are system specific. To see if the CPU supports TXT, run the following (SMX (Safe Mode Extensions) indicates the CPU does support TXT):</p> <p><code># grep smx /proc/cpuinfo</code></p> <p>Also note, the TrenchBoot project has a hardware test matrix though only the Intel systems are relevant at present:</p> <ul> <li>Test Matrix</li> </ul>"},{"location":"user-docs/QUICKSTART/#linux","title":"Linux","text":"<p>TrenchBoot is an active open-source project for system launch integrity, from which the Secure Launch feature is being upstreamed to the Linux kernel.</p> <p>The following repository and branch have the latest release of the Secure Launch feature. This is a vanilla Linux kernel based off a torvalds/master branch snapshot at the time time patch set was assembled. The patches could be applied to different distros of Linux, probably requiring some rebasing:</p> <ul> <li>Latest Linux Patch Set Version 14</li> </ul> <p>The Secure Launch feature is enabled through a Kconfig setting and can be found here using e.g. <code>make menuconfig</code>:</p> <p><code>\"Processor type and features\" -&gt; \"[ ] Secure Launch support\"</code></p> <p>The Linux Secure Launch in-tree documentation mentioned in the first section contains other instructions on properly configuring a Secure Launch kernel.</p>"},{"location":"user-docs/QUICKSTART/#grub","title":"GRUB","text":"<p>Each recent release of the Linux patches is accompanied by a GRUB branch in TrenchBoot that works with the specified version. The branch for version 9 can be found here:</p> <ul> <li>GRUB for Version 14</li> </ul> <p>This version of GRUB is based off of upstream GRUB 2.12 with the patches to support the Secure Launch feature. The following is a basic set of instructions for building a standalone version of UEFI GRUB on this branch:</p> <pre><code>$ cd &lt;grub-branch-checkout-location&gt;\n$ ./bootstrap\n$ mkdir build\n$ cd build\n$ ../configure --with-platform=efi --target=x86_64\n$ make\n$ ./grub-mkimage -O x86_64-efi -o grubx64.efi -p /EFI/redhat -d grub-core all_video boot btrfs cat chain configfile echo efifwsetup efinet ext2 fat font gfxmenu gfxterm gzio halt hfsplus iso9660 jpeg loadenv loopback lvm mdraid09 mdraid1x minicmd normal part_apple part_msdos part_gpt password_pbkdf2 png reboot regexp search search_fs_uuid search_fs_file search_label serial sleep syslinuxcfg test tftp video xfs backtrace http linux usb usbserial_common usbserial_pl2303 usbserial_ftdi usbserial_usbdebug keylayouts at_keyboard multiboot2\n</code></pre> <p>The final command will produce the UEFI GRUB image <code>grubx64.efi</code> needed.</p>"},{"location":"user-docs/QUICKSTART/#configuration","title":"Configuration","text":"<p>There is a new GRUB command that instructs GRUB to initiate a Secure Launch called <code>slaunch</code>. This is an example of a GRUB menuentry that would be used to do a Secure Launch of the Linux kernel:</p> <pre><code>menuentry 'Linux with Secure Launch 6.15.0-rc2-master-v14' --unrestricted {\n        load_video\n        insmod gzio\n        insmod part_gpt\n        insmod xfs\n        if [ x$feature_platform_search_hint = xy ]; then\n                search --no-floppy --fs-uuid --set=root bba24662-776e-4396-9b1e-9ee5606d79b8\n        else\n                search --no-floppy --fs-uuid --set=root bba24662-776e-4396-9b1e-9ee5606d79b8\n        fi\n        slaunch\n        linux /vmlinuz-6.15.0-rc2-master-v14 root=/dev/mapper/root ro crashkernel=auto resume=/dev/mapper/swap rd.lvm.lv=my/root rd.lvm.lv=my/swap rhgb console=ttyS0,115200n8 console=tty0 LANG=en_US.UTF-8\n        initrd /initrd-6.15.0-rc2-master-v14.img\n        slaunch_module /txt-sinit-for-given-platform\n}\n</code></pre> <p>Note this example contains the optional <code>slaunch_module</code> command that tells GRUB to load an external SINIT ACM for this configuration. In general, server platforms contain an existing SINIT ACM in the firmware and this line is not needed. For client platforms, an external one is required to be supplied. The SINIT ACM for a given platform can be acquired from Intel:</p> <ul> <li>Intel SINIT ACM information</li> </ul>"},{"location":"user-docs/QUICKSTART/#validation","title":"Validation","text":"<p>There are a number of ways to validate that a successful Secure Launch was done. Using serial logging or <code>dmesg</code>, search for the string \"TXT\" after booting:</p> <pre><code>[root@my-system ~]# dmesg | grep TXT\n[    0.000094] slaunch: Intel TXT setup complete\n[    2.617782] slaunch: TXT AP startup vector address updated\n</code></pre> <p>That indicates a successful Secure Launch boot. Another way is to display the Secure Launch TPM event log. This can be done as follows after booting (note only the tail end of the log is shown here for brevity, the rest is snippped):</p> <pre><code>[root@my-system ~]# cat /sys/kernel/security/slaunch/eventlog | hexdump -C\n...\n[snip]\n...\n00000490  a3 e2 de 6b fb 1f 79 ef  c9 5e de bf ef bf 92 fb  |...k..y..^......|\n000004a0  fc b2 89 ea 64 c1 d7 d2  99 fb 49 e6 12 00 00 00  |....d.....I.....|\n000004b0  4d 65 61 73 75 72 65 64  20 53 4c 52 20 54 61 62  |Measured SLR Tab|\n000004c0  6c 65 12 00 00 00 02 05  00 00 01 00 00 00 0b 00  |le..............|\n000004d0  cd 64 bf e1 70 96 4c ce  53 2f 2f 7a 85 85 fe f0  |.d..p.L.S//z....|\n000004e0  05 22 40 f6 62 18 bf 94  2a 2f 3d 14 b1 25 60 31  |.\"@.b...*/=..%`1|\n000004f0  18 00 00 00 4d 65 61 73  75 72 65 64 20 62 6f 6f  |....Measured boo|\n00000500  74 20 70 61 72 61 6d 65  74 65 72 73 11 00 00 00  |t parameters....|\n00000510  02 05 00 00 01 00 00 00  0b 00 18 7d 80 8f 2c ca  |...........}..,.|\n00000520  03 bf a7 54 ff 1d 16 6d  49 51 25 f6 bc ec 46 dc  |...T...mIQ%...F.|\n00000530  23 a7 39 a8 db 96 28 8e  d4 1d 16 00 00 00 4d 65  |#.9...(.......Me|\n00000540  61 73 75 72 65 64 20 4b  65 72 6e 65 6c 20 69 6e  |asured Kernel in|\n00000550  69 74 72 64 12 00 00 00  02 05 00 00 01 00 00 00  |itrd............|\n00000560  0b 00 11 02 09 6f c6 1d  78 11 87 1a 93 49 10 2f  |.....o..x....I./|\n00000570  14 69 dd 45 b8 c3 03 e7  e6 80 6e 21 9b 87 47 90  |.i.E......n!..G.|\n00000580  d6 27 1c 00 00 00 4d 65  61 73 75 72 65 64 20 4b  |.'....Measured K|\n00000590  65 72 6e 65 6c 20 63 6f  6d 6d 61 6e 64 20 6c 69  |ernel command li|\n000005a0  6e 65 12 00 00 00 02 05  00 00 01 00 00 00 0b 00  |ne..............|\n000005b0  b2 29 3f 3c da 25 4a 78  61 be 76 91 3e 06 f9 5d  |.)?&lt;.%Jxa.v.&gt;..]|\n000005c0  7d 6b 0d 75 6b 30 74 0c  26 b2 76 96 1e 60 19 a5  |}k.uk0t.&amp;.v..`..|\n000005d0  18 00 00 00 4d 65 61 73  75 72 65 64 20 55 45 46  |....Measured UEF|\n000005e0  49 20 6d 65 6d 6f 72 79  20 6d 61 70 11 00 00 00  |I memory map....|\n000005f0  04 05 00 00 01 00 00 00  0b 00 00 00 00 00 00 00  |................|\n00000600  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00008000\n</code></pre> <p>The final measurements starting with the description \"Measured...\" are put in the log by the Secure Launch kernel code after successfully running. During a poweroff, restart or a kexec of another kernel, the following log lines will show TXT being properly disabled and SMX mode being exited.:</p> <pre><code>[  696.907094] slaunch: TXT clear secrets bit and unlock memory complete.\n[  696.914827] slaunch: TXT SEXIT complete.\n</code></pre>"},{"location":"user-docs/QUICKSTART/#troubleshooting","title":"Troubleshooting","text":"<p>See the Troubleshooting page.</p>"},{"location":"user-docs/build_grub/","title":"Building and installing GRUB","text":"<p>At the time of writing\u00a0(August 2024) EFI and legacy changes are on different branches in the same repository and neither builds on top of the other in terms of commit history.  Either clone the repository in full and switch between branches to build both versions or use shallow clones as shown below.</p> <p>If your system isn't setup for development, you might want to use trenchboot-sdk Docker container.  It can be run like this to perform a build:</p> <pre><code>docker run --rm -it -v \"$PWD:$PWD\" -w \"$PWD\" \\\n           -e HOME=\"$PWD/home\" \\\n           --user \"$(id -u):$(id -g)\" \\\n           ghcr.io/trenchboot/trenchboot-sdk:master /bin/bash\n</code></pre> <p>Setting <code>$HOME</code> is necessary because GRUB will try to use <code>ccache</code> which fails if there is no <code>$HOME</code>.</p>"},{"location":"user-docs/build_grub/#efi-version","title":"EFI version","text":""},{"location":"user-docs/build_grub/#build","title":"Build","text":"<pre><code># check out the sources\ngit clone --branch grub-sl-2.12-v9 --depth 1 \\\n          https://github.com/TrenchBoot/grub.git\ncd grub\n\n# make the checkout buildable\n./bootstrap\n\n# configure\nmkdir build\ncd build\n../configure --with-platform=efi --target=x86_64\n\n# build\nmake -j$(nproc)\n</code></pre>"},{"location":"user-docs/build_grub/#setup","title":"Setup","text":"<pre><code># also from inside build/ directory\necho 'configfile ${cmdpath}/grub.cfg' &gt; embedded.cfg\n./grub-mkimage -O x86_64-efi -o grubx64.efi -p / -c embedded.cfg -d grub-core \\\n               all_video boot btrfs cat chain configfile echo efifwsetup \\\n               efinet ext2 fat font gfxmenu gfxterm gzio halt hfsplus iso9660 \\\n               jpeg loadenv loopback lvm mdraid09 mdraid1x minicmd normal \\\n               part_apple part_msdos part_gpt password_pbkdf2 png reboot \\\n               regexp search search_fs_uuid search_fs_file search_label serial \\\n               sleep syslinuxcfg test tftp video xfs backtrace http linux usb \\\n               usbserial_common usbserial_pl2303 usbserial_ftdi \\\n               usbserial_usbdebug keylayouts at_keyboard multiboot2\n</code></pre> <p>The first command creates an embedded config which sources grub.cfg in the directory in which GRUB image is located.</p> <p>The second command produces the UEFI GRUB image named <code>grubx64.efi</code>.  The image along with a suitable <code>grub.cfg</code> needs to be installed on a EFI System Partition\u00a0(ESP) and pointed at so firmware can find it\u00a0(via Setup UI or a tool like <code>efibootmgr</code>).  It can also be started manually from a UEFI shell for a test.</p>"},{"location":"user-docs/build_grub/#legacy-version","title":"Legacy version","text":""},{"location":"user-docs/build_grub/#build_1","title":"Build","text":"<pre><code># check out the sources\ngit clone --branch tb-2.12-57-v1 --depth 1 https://github.com/TrenchBoot/grub.git\ncd grub\n\n# make the checkout buildable\n./bootstrap\n\n# configure\nmkdir build\ncd build\n../configure --prefix=$PWD/local-install --target=i386\n\n# build\nmake -j$(nproc)\n</code></pre>"},{"location":"user-docs/build_grub/#setup_1","title":"Setup","text":"<p>Installation for legacy boot from inside of a container requires access to device files and mounting of boot directory.  For this reason the container needs to be started as <code>root</code> (inside of the container, don't prepend <code>sudo</code> to the command) and be a privileged one:</p> <pre><code>docker run --rm -it -v \"$PWD:$PWD\" -w \"$PWD\" \\\n           --user root:root --privileged \\\n           ghcr.io/trenchboot/trenchboot-sdk:master /bin/bash\n</code></pre> <pre><code># if done in a container\ncd build\nmount BOOT-PARTITION PATH-TO-BOOT\n\n# also from inside build/ directory\nmake install\nlocal-install/sbin/grub-install --target=i386-pc \\\n                                --boot-directory PATH-TO-BOOT \\\n                                DISK-DEVICE\n</code></pre> <p>In the second command above replace:</p> <ul> <li><code>BOOT-PARTITION</code> with the <code>/dev/...</code> file corresponding to the boot partition</li> <li><code>PATH-TO-BOOT</code> with the path to where the boot partition is mounted\u00a0(<code>grub/</code>   directory will be created there)</li> <li><code>DISK-DEVICE</code> with the <code>/dev/...</code> file corresponding to the drive\u00a0(not a   partition) on which GRUB\u00a0is to be installed (double check before running the   command to avoid accidentally overwriting some working GRUB setup)</li> </ul> <p>If you get a weird error like <code>error: disk `hostdisk//dev/sda1' not found.</code>, it means that GRUB doesn't have write permissions for device files.</p>"},{"location":"user-docs/build_grub/#configuration","title":"Configuration","text":"<p>There is a new GRUB command, which instructs GRUB to initiate a Secure Launch when booting an OS, called <code>slaunch</code>.  This is an example of a GRUB menuentry that would be used to do a Secure Launch of the Linux kernel:</p> <pre><code>menuentry 'Linux with Secure Launch 6.8.0-rc3-master-v8' --unrestricted {\n        load_video\n        insmod gzio\n        insmod part_gpt\n        insmod xfs\n        search --no-floppy --fs-uuid --set=root bba24662-776e-4396-9b1e-9ee5606d79b8\n        slaunch\n        slaunch_module /dce-for-a-given-platform\n        linux /vmlinuz-6.8.0-rc3-master-v8 root=/dev/mapper/root ro crashkernel=auto resume=/dev/mapper/swap rd.lvm.lv=my/root rd.lvm.lv=my/swap rhgb console=ttyS0,115200n8 console=tty0 LANG=en_US.UTF-8\n        initrd /initrd-6.8.0-rc3-master-v8.img\n}\n</code></pre> <p>Note also the optional <code>slaunch_module</code> command which tells GRUB to load an external SINIT ACM for this configuration.  In general, server platforms contain an existing SINIT ACM in the firmware and this line can be omitted.  For client platforms, an external ACM is required to be supplied.  The SINIT ACM for a given platform can be acquired from Intel.</p>"},{"location":"user-docs/build_grub/#validation","title":"Validation","text":"<p>There are a number of ways to validate that a successful Secure Launch was done.  Using serial logging or <code>dmesg</code>, search for the string \"TXT\" after booting:</p> <pre><code>[root@my-system ~]# dmesg | grep TXT\n[    0.000094] slaunch: Intel TXT setup complete\n[    2.617782] slaunch: TXT AP startup vector address updated\n</code></pre> <p>That indicates a successful Secure Launch boot.  Another way is to display the Secure Launch TPM event log.  This can be done as follows after booting\u00a0(note only the tail end of the log is shown here for brevity, the rest is snippped):</p> <pre><code>[root@my-system ~]# cat /sys/kernel/security/slaunch/eventlog | hexdump -C\n...\n[snip]\n...\n00000490  a3 e2 de 6b fb 1f 79 ef  c9 5e de bf ef bf 92 fb  |...k..y..^......|\n000004a0  fc b2 89 ea 64 c1 d7 d2  99 fb 49 e6 12 00 00 00  |....d.....I.....|\n000004b0  4d 65 61 73 75 72 65 64  20 53 4c 52 20 54 61 62  |Measured SLR Tab|\n000004c0  6c 65 12 00 00 00 02 05  00 00 01 00 00 00 0b 00  |le..............|\n000004d0  cd 64 bf e1 70 96 4c ce  53 2f 2f 7a 85 85 fe f0  |.d..p.L.S//z....|\n000004e0  05 22 40 f6 62 18 bf 94  2a 2f 3d 14 b1 25 60 31  |.\"@.b...*/=..%`1|\n000004f0  18 00 00 00 4d 65 61 73  75 72 65 64 20 62 6f 6f  |....Measured boo|\n00000500  74 20 70 61 72 61 6d 65  74 65 72 73 11 00 00 00  |t parameters....|\n00000510  02 05 00 00 01 00 00 00  0b 00 18 7d 80 8f 2c ca  |...........}..,.|\n00000520  03 bf a7 54 ff 1d 16 6d  49 51 25 f6 bc ec 46 dc  |...T...mIQ%...F.|\n00000530  23 a7 39 a8 db 96 28 8e  d4 1d 16 00 00 00 4d 65  |#.9...(.......Me|\n00000540  61 73 75 72 65 64 20 4b  65 72 6e 65 6c 20 69 6e  |asured Kernel in|\n00000550  69 74 72 64 12 00 00 00  02 05 00 00 01 00 00 00  |itrd............|\n00000560  0b 00 11 02 09 6f c6 1d  78 11 87 1a 93 49 10 2f  |.....o..x....I./|\n00000570  14 69 dd 45 b8 c3 03 e7  e6 80 6e 21 9b 87 47 90  |.i.E......n!..G.|\n00000580  d6 27 1c 00 00 00 4d 65  61 73 75 72 65 64 20 4b  |.'....Measured K|\n00000590  65 72 6e 65 6c 20 63 6f  6d 6d 61 6e 64 20 6c 69  |ernel command li|\n000005a0  6e 65 12 00 00 00 02 05  00 00 01 00 00 00 0b 00  |ne..............|\n000005b0  b2 29 3f 3c da 25 4a 78  61 be 76 91 3e 06 f9 5d  |.)?&lt;.%Jxa.v.&gt;..]|\n000005c0  7d 6b 0d 75 6b 30 74 0c  26 b2 76 96 1e 60 19 a5  |}k.uk0t.&amp;.v..`..|\n000005d0  18 00 00 00 4d 65 61 73  75 72 65 64 20 55 45 46  |....Measured UEF|\n000005e0  49 20 6d 65 6d 6f 72 79  20 6d 61 70 11 00 00 00  |I memory map....|\n000005f0  04 05 00 00 01 00 00 00  0b 00 00 00 00 00 00 00  |................|\n00000600  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n00008000\n</code></pre> <p>The final measurements starting with the description \"Measured...\" are put in the log by the Secure Launch kernel code if everything went fine.  During a poweroff, restart or a kexec of another kernel, the following log lines will indicate that TXT was properly disabled and SMX mode was left:</p> <pre><code>[  696.907094] slaunch: TXT clear secrets bit and unlock memory complete.\n[  696.914827] slaunch: TXT SEXIT complete.\n</code></pre> <p>If <code>tpm2_eventlog</code> is installed, it can be used parse the log into a readable form:</p> <pre><code>[root@my-system ~]# tpm2_eventlog /sys/kernel/security/slaunch/eventlog\n...\n</code></pre>"},{"location":"user-docs/build_linux/","title":"Building and installing Linux","text":"<p>If your system isn't setup for development, you might want to run build commands inside of trenchboot-sdk Docker container which can be started like this:</p> <pre><code>docker run --rm -it -v \"$PWD:$PWD\" -w \"$PWD\" --user \"$(id -u):$(id -g)\" \\\n           -e HOME=\"$PWD/home\" \\\n           ghcr.io/trenchboot/trenchboot-sdk:master /bin/bash\n</code></pre> <p>Setting <code>$HOME</code> is necessary because <code>ccache</code> fails if there is no <code>$HOME</code>.</p>"},{"location":"user-docs/build_linux/#preparing-for-build","title":"Preparing for build","text":"<pre><code># clone the latest version (at the time of writing)\ngit clone --branch linux-sl-master-9-12-24-v11 --depth 1 \\\n          https://github.com/TrenchBoot/linux.git\n\n# change working directory\ncd linux\n\n# prepare for out of tree build for simpler cleanup and ability to build\n# multiple configs\nmkdir tb\nexport KBUILD_OUTPUT=$PWD/tb\n</code></pre>"},{"location":"user-docs/build_linux/#note-on-initrd","title":"Note on initrd","text":"<p>If initrd is necessary, one might embed required drivers to perform the boot as part of the configuration or build initrd image after installing everything by specifying <code>6.11-rc7-v11-tb</code> version.  Details on how to perform either of these options are outside the scope of these instructions.</p>"},{"location":"user-docs/build_linux/#configuring-the-kernel","title":"Configuring the kernel","text":"<p>Details on what should be enabled and why can be found in <code>Documentation/security/launch-integrity/secure_launch_details.rst</code>, steps below provide only basic information on configuration options.</p> <p>Default configuration file is used for a base as an example while you might want to start with the one from the currently running kernel\u00a0(<code>zcat /proc/config.gz &gt; .config</code> or <code>cp /boot/config .config</code>) and enable the listed options in a menu\u00a0(<code>make menuconfig</code>) after looking them up via search\u00a0(hit <code>/</code> and enter, for example, <code>X86_X2APIC</code>, then hit <code>1</code> to navigate to the option and change its value).</p> <p>Start with default configuration file:</p> <pre><code>cp arch/x86/configs/x86_64_defconfig \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>Enable X2APIC which is required by TXT:</p> <pre><code>echo CONFIG_X86_X2APIC=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>Disable KASLR which can compromise security or cause crashes\u00a0(alternatively, pass <code>nokaslr</code> kernel parameter):</p> <pre><code>echo '# CONFIG_RANDOMIZE_BASE is not set' &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>Select strict IOMMU translated mode by default for better device isolation at the cost of performance\u00a0(can be omitted or enabled via <code>iommu.strict=1</code> kernel parameter):</p> <pre><code>echo CONFIG_IOMMU_DEFAULT_DMA_STRICT=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>Enable at least one driver for a TPM without which no DRTM can be done:</p> <pre><code># this might be enough (e.g., for firmware TPM in recent CPUs)\necho CONFIG_TCG_TPM=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_CRB=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n\n# this enables the rest of TPM drivers\necho CONFIG_TCG_TIS=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_TIS_I2C=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_TIS_I2C_CR50=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_TIS_I2C_ATMEL=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_TIS_I2C_INFINEON=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_TIS_I2C_NUVOTON=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_NSC=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_ATMEL=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_INFINEON=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_TCG_TIS_ST33ZP24_I2C=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>TPM drivers are located in <code>Device Drivers \u2192 Character devices \u2192 TPM Hardware Support</code> menu where more detailed information about the above options can be found.</p> <p>Enable Secure Launch itself:</p> <pre><code>echo CONFIG_SECURE_LAUNCH=y &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>Add a suffix to the version to avoid conflicts, also disable appending of commit hash:</p> <pre><code>echo 'CONFIG_LOCALVERSION=\"-v11-tb\"' &gt;&gt; \"$KBUILD_OUTPUT/.config\"\necho CONFIG_LOCALVERSION_AUTO=n &gt;&gt; \"$KBUILD_OUTPUT/.config\"\n</code></pre> <p>Now make the configuration usable by the build system by completing it:</p> <pre><code>make olddefconfig\n</code></pre>"},{"location":"user-docs/build_linux/#build","title":"Build","text":"<pre><code># the kernel\nmake -j$(nproc) bzImage\n\n# and its modules\nmake -j$(nproc) modules\n</code></pre>"},{"location":"user-docs/build_linux/#installation","title":"Installation","text":"<p>The following steps should be run outside of a container either as root user or with <code>sudo</code> prepended to them:</p> <pre><code># kernel\ncp \"$KBUILD_OUTPUT/arch/x86/boot/bzImage\" /boot/vmlinuz-6.11-rc7-v11-tb\ncp \"$KBUILD_OUTPUT/.config\" /boot/config-6.11-rc7-v11-tb\ncp \"$KBUILD_OUTPUT/System.map\" /boot/System.map-6.11-rc7-v11-tb\n\n# modules\nmake modules_install\n</code></pre>"},{"location":"user-docs/build_linux/#use-with-trenchboot-grub2","title":"Use with TrenchBoot GRUB2","text":"<pre><code>menuentry 'Linux with Secure Launch 6.11-rc7 v11' --unrestricted {\n    insmod part_gpt\n    search --no-floppy --fs-uuid --set=root BOOT-FSUUID\n    slaunch\n    slaunch_module /DCE-FOR-A-GIVEN-PLATFORM\n    linux /vmlinuz-6.11-rc7-v11-tb root=PARTUUID=ROOT-PARTUUID ro console=ttyS0,115200n8 console=tty0\n\n    # uncomment if used\n    # initrd /initrd-6.11-rc7-v11-tb.img\n}\n</code></pre> <p>Things that must be replaced\u00a0(add additional kernel parameters and GRUB commands as needed):</p> <ul> <li><code>DCE-FOR-A-GIVEN-PLATFORM</code> with path to ACM or SKL file on boot partition</li> <li><code>BOOT-FSUUID</code> with file-system UUID\u00a0(can be found via <code>lsblk -o +UUID</code>)</li> <li><code>ROOT-PARTUUID</code> with partition UUID\u00a0(can be found via <code>blkid</code>)</li> <li>if <code>/boot</code> is not a separate partition, paths should be modified to add   <code>/boot</code> prefix</li> </ul>"},{"location":"user-docs/install_aem/","title":"Installing TrenchBoot AEM in Qubes OS","text":"<p>This document shows how to install Anti Evil Maid from packages produced by 3mdeb as part of TrenchBoot as Anti Evil Maid project. If you wish to build the components yourself, please refer to documentation for developers instead.</p>"},{"location":"user-docs/install_aem/#installation","title":"Installation","text":"<p>To install, you have to first add a new repository and import a public part of a key that was used to sign RPM packages.</p>"},{"location":"user-docs/install_aem/#adding-aem-repository","title":"Adding AEM repository","text":"<p>To add a new repository, create in dom0 as root <code>/etc/yum.repos.d/aem.repo</code> with the following content:</p> <pre><code>[aem]\nname = Anti Evil Maid based on TrenchBoot\nbaseurl = https://dl.3mdeb.com/rpm/QubesOS/r4.2/current/dom0/fc37\ngpgcheck = 1\ngpgkey = https://dl.3mdeb.com/rpm/QubesOS/r4.2/current/dom0/fc37/RPM-GPG-KEY-tb-aem\nenabled = 1\n</code></pre> <p>The key specified in the file must be downloaded and imported to RPM:</p> <pre><code>qvm-run --pass-io sys-net \\\n    'curl -L https://dl.3mdeb.com/rpm/QubesOS/r4.2/current/dom0/fc37/RPM-GPG-KEY-tb-aem' \\\n    &gt; RPM-GPG-KEY-tb-aem\nsudo rpm --import RPM-GPG-KEY-tb-aem\n</code></pre> <p>Now it should be possible to download and install packages from AEM repository.</p>"},{"location":"user-docs/install_aem/#intel-systems-dependencies","title":"Intel systems dependencies","text":"<p>If your device has an Intel CPU, download official package from Intel and extract ACM appropriate for your platform to <code>/boot/</code>.</p>"},{"location":"user-docs/install_aem/#installing-prerequisite-packages","title":"Installing prerequisite packages","text":""},{"location":"user-docs/install_aem/#qubes-repository-dependencies","title":"Qubes repository dependencies","text":"<p>Start by installing prerequisite packages. Those are not part of newly added repository, but <code>qubes-dom0-current-testing</code>:</p> <pre><code>sudo qubes-dom0-update --enablerepo=qubes-dom0-current-testing \\\n    oathtool \\\n    openssl \\\n    qrencode \\\n    tpm-extra \\\n    trousers-changer \\\n    tpm-tools\n</code></pre>"},{"location":"user-docs/install_aem/#prepare-a-list-of-aem-packages","title":"Prepare a list of AEM packages","text":"<p>For convenience, the packages can be saved to an environment variable:</p> <pre><code>packages=(\n    \"anti-evil-maid-4.2.1-1.fc37.x86_64\"\n    \"grub2-common-2.13-1.fc37.noarch\"\n    \"grub2-tools-2.13-1.fc37.x86_64\"\n    \"grub2-tools-extra-2.13-1.fc37.x86_64\"\n    \"grub2-tools-minimal-2.13-1.fc37.x86_64\"\n    \"python3-xen-4.17.5-7.fc37.x86_64\"\n    \"xen-4.17.5-7.fc37.x86_64\"\n    \"xen-hypervisor-4.17.5-7.fc37.x86_64\"\n    \"xen-libs-4.17.5-7.fc37.x86_64\"\n    \"xen-licenses-4.17.5-7.fc37.x86_64\"\n    \"xen-runtime-4.17.5-7.fc37.x86_64\"\n)\n</code></pre>"},{"location":"user-docs/install_aem/#legacy-systems","title":"Legacy Systems","text":"<p>If your system has a legacy BIOS, run:</p> <pre><code>packages+=(\n    \"grub2-pc-2.13-1.fc37.x86_64\"\n    \"grub2-pc-modules-2.13-1.fc37.noarch\"\n)\n</code></pre>"},{"location":"user-docs/install_aem/#uefi-systems","title":"UEFI Systems","text":"<p>If your system has a UEFI BIOS, run:</p> <pre><code>packages+=(\n    \"grub2-efi-x64-2.13-1.fc37.x86_64\"\n    \"grub2-efi-x64-modules-2.13-1.fc37.noarch\"\n)\n</code></pre>"},{"location":"user-docs/install_aem/#amd-systems","title":"AMD systems","text":"<p>If your systems has an AMD CPU, run:</p> <pre><code>packages+=(\n    \"secure-kernel-loader-0+224af56470eff64f2cc1f74c1e1099d3f170636f-1.fc37.x86_64\"\n)\n</code></pre>"},{"location":"user-docs/install_aem/#installing","title":"Installing","text":"<p>Install the packages (first command reinstalls existing packages in case the same version numbers exist on official Qubes repositories, second one only adds new packages):</p> <pre><code>qubes-dom0-update --disablerepo=\"*\" --enablerepo=aem --action=reinstall -y ${packages[@]}\nqubes-dom0-update --disablerepo=\"*\" --enablerepo=aem --action=install -y ${packages[@]}\n</code></pre>"},{"location":"user-docs/install_aem/#updating-grub-on-legacy-systems","title":"Updating GRUB on legacy systems","text":"<p>Booting on legacy systems requires manual installation of GRUB2 to the MBR of disk where Qubes OS is stored. If your systems has a Legacy BIOS, follow these instructions.</p> <p>If you are sure where the root partition is located, you can skip the following steps explaining how to find it out.</p> <p>To check on which drive is your OS installed, run:</p> <ol> <li> <p>Get the Logical Volume (LV) file:</p> <pre><code>df --output=source /\n</code></pre> <p>Example LV file: <code>/dev/mapper/qubes_dom0-root</code></p> </li> <li> <p>Map the Logical Volume (LV) to a Volume Group (VG):</p> <pre><code>sudo lvs /dev/mapper/qubes_dom0-root --noheadings -o vg_name\n</code></pre> <p>Example VG name: <code>qubes_dom0</code></p> </li> <li> <p>Map the Volume Group to a Physical Volume (PV):</p> <pre><code>sudo vgs --noheadings -o pv_name qubes_dom0\n</code></pre> <p>Example PV file: <code>/dev/mapper/luks-12345678-1234-1234-1234-123456789abc</code> (GUID)</p> </li> <li> <p>Find the PV name in <code>lsblk</code> output and check on which device it is located.</p> <pre><code>lsblk -o NAME\n</code></pre> <p>Example output:</p> <pre><code>sda\n\u251c\u2500sda1\n\u251c\u2500sda2\n\u2514\u2500sda3\n  \u2514\u2500luks-12345678-1234-1234-1234-123456789abc\n</code></pre> <p>The drive on which the root partition is located in this example is therefore <code>/dev/sda</code>.</p> </li> </ol> <p>Remember that GRUB2 must be installed on disk and not on partition, so don\u2019t use <code>sda1</code>, <code>nvme0n1p1</code> etc. This step should be skipped on UEFI systems.</p> <pre><code>sudo grub2-install /dev/sda\n</code></pre>"},{"location":"user-docs/install_aem/#installing-main-aem-package","title":"Installing main AEM package","text":"<p>Finally, <code>anti-evil-maid</code> package may be installed:</p> <pre><code>sudo qubes-dom0-update --disablerepo=\"*\" --enablerepo=aem \\\n    anti-evil-maid-4.2.1-1.fc37.x86_64\n</code></pre>"},{"location":"user-docs/install_aem/#provisioning","title":"Provisioning","text":"<p>All packages are in place. Before we can proceed with provisioning AEM, the TPM must be cleared in the BIOS. Some platforms may require disabling Intel Trusted Execution Technology (TXT) in order to clear TPM. After you clear the TPM, remember to enable Intel TXT back, otherwise AEM will not work. Once TPM is cleared, perform the TPM setup:</p> <pre><code>sudo anti-evil-maid-tpm-setup\n</code></pre> <p></p> <p>You will be prompted to set the SRK password, it is a password to access TPM\u2019s nonvolatile storage where the AEM secrets will be sealed. If you failed to clear the TPM, you will be shown a message like this:</p> <p></p> <p>In that case, try clearing the TPM in your BIOS and run the command again.</p> <p>Now all that's left is proper installation of AEM. There are different options, refer to <code>anti-evil-maid-install -h</code> for examples. In the simplest case, AEM is installed on boot partition (not disk, i.e. <code>sda1</code> instead of <code>sda</code> etc.) of Qubes OS. Run this command to find out where your boot partition is installed:</p> <pre><code>df --output=source /boot\n</code></pre> <p>Assuming that your boot partition is installed on <code>/dev/sda1</code>, the installation can be done with a simple command:</p> <pre><code>sudo anti-evil-maid-install /dev/sda1\n</code></pre> <p></p> <p>After that, reboot the platform. On first boot you will be asked for the SRK password, followed by another question for disk encryption password, after which a screen mentioning absent secret file will be shown:</p> <p></p> <p>This is expected on the first boot after installation or an update to one or more of measured components (GRUB, Xen, dom0 kernel and initramfs). After rebooting for the second time, the Anti Evil Maid should be up and running.</p>"},{"location":"user-docs/openqa/","title":"TrenchBoot OpenQA user guide","text":""},{"location":"user-docs/openqa/#openqa","title":"OpenQA","text":"<p>OpenQA is a tool for performing automated testing of operating systems developed by SUSE. It is used by multiple Linux distributions like OpenSUSE, Fedora and QubesOS.</p> <p>The results of TrenchBoot automated tests can be viewed on the project's OpenQA instance.</p>"},{"location":"user-docs/openqa/#usage","title":"Usage","text":"<p>The website allows anyone to freely monitor all the details about the tests run, including:</p> <ul> <li>configuration variables</li> <li>collected logs</li> <li>screenshots and a video recording of the screen for the duration of a test</li> <li>the results and the reasons behind fails</li> </ul> <p>Anyone can login to the website via GitHub, but only the authorized accounts are able to:</p> <ul> <li>run the tests</li> <li>create new tests</li> <li>modify any settings</li> <li>add new devices</li> </ul>"},{"location":"user-docs/openqa/#navigation","title":"Navigation","text":"<p>The main page of the OpenQA website shows a summary of the most recent test runs.</p> <p>The tests are organized into Job Groups, like \"Qubes\". The test groups contain Products, like \"Build4.2.3\". Each Product consists of multiple Test Suites. On the main page every distinct Product has a progress bar showing how many Test Suites have passed, are running, are finished and were skipped.</p> Image of the main page, show job groups, products and test suite progress <p>From this page there is a couple of options for further navigation to access more precise data.</p>"},{"location":"user-docs/openqa/#job-group","title":"Job Group","text":"<p>Job Groups simply a way to organize all of the maintained Products into thematic categories.</p> <p>Clicking on the name of a Job Group shows its details. Most importantly all of the historical Products that were published as a part of the Job Group. In addition to that, authorized users can leave comments about the Job Group there.</p> Image of the Job Group view"},{"location":"user-docs/openqa/#product","title":"Product","text":"<p>A Product represents one run of a set of test suites with given parameters. The name of each product consists of the following parts:</p> <ul> <li>The name of the tested OS distribution - to run tests on every maintained   distribution</li> <li>The version - to allow running the tests on every new release</li> <li>The flavor - to allow testing every flavor of the OS separately</li> <li>The hardware architecture - to run on every supported architecture</li> </ul> <p>Testing TrenchBoot requires to cover all of the supported hardware platforms, not only run a single test per hardware architecture. For this reason the Flavor field of a Product is used a bit unconventionally. At this moment TrenchBoot does not consist of multiple Flavors and the field is used to determine:</p> <ul> <li>on which hardware platform the tests were performed</li> <li>whether it was installed on a Legacy or an UEFI BIOS</li> </ul> Product name made of four sections <p>Clicking on a Product from the main page, or the Job Group details page shows the summary of the Product and a list of the Test Suites associated with it.</p> Image of a product view with list of tests"},{"location":"user-docs/openqa/#test-suite","title":"Test Suite","text":"<p>Test Suites are the essence of the OpenQA web panel. Next to every test suite you can see a small colorful circle informing about the status of the Test Suite. The most common statuses are:</p> <ul> <li>Gray - Skipped or Canceled (can be disambiguated via a tooltip text)<ul> <li>The test was decided to not be performed based on the results of other tests, like its dependencies failing</li> <li>The test was canceled by the user before finishing</li> </ul> </li> <li>Green - Pass<ul> <li>The test passed without any issues</li> </ul> </li> <li>Red - Fail<ul> <li>The test encountered a critical issue, the testing is stopped</li> </ul> </li> <li>Yellow - Soft Fail<ul> <li>The test encountered a non-critical issue, the testing may continue</li> </ul> </li> </ul> <p>By clicking on the status circle icon informing on the status of the Test Suite, the details of the selected Test Suite can be accessed.</p> Image of the circle to press, which is very small and a bit unintuitive, marked with a red rectangle <p>When accessing the Test Suites from the All Tests view shown above, you can also click on the blue Test Suite name to access the details. On most other pages pressing the circle is the only way to do so.</p> <p>Upon doing so the page of the selected Test Suite run as a part of a Product will be shown. It contains a short summary of the Test Suite and a tab bar containing a couple tabs with more details.</p>"},{"location":"user-docs/openqa/#details-tab","title":"Details Tab","text":"<p>The default tab shown when selecting a finished Test Suite is its Details tab. It contains a summary of all of the Tests being a part of the Test Suite and their statuses.</p> <p>Every single test consists of one or more Asserts, which are used to determine whether the test Passes or Fails. The Details page shows the proofs for every Assert during a test. The proofs are:</p> <ul> <li>screenshots, which are being asserted   by comparing selected parts of the screen to the expected outcomes</li> <li>text logs, compared to expected outputs</li> </ul> The details tab <p>The details of any assert and the reason for pass or fail can be viewed by clicking on the corresponding box in any Test Suite.</p> Image of a screenshot needle assert selected Image of a text needle assert selected"},{"location":"user-docs/openqa/#logs-assets-tab","title":"Logs &amp; Assets Tab","text":"<p>The Logs &amp; Assets tab contains all of the downloadable content created during the Test Suite. This includes:</p> <ul> <li><code>Video</code> - A video recording of the screen for the whole duration of the Test Suite</li> <li><code>autoinst-log.txt</code> - Logs from the test</li> <li><code>worker-log.txt</code> - Logs created by the OpenQA worker process managing   the tested device</li> <li><code>vars.json</code> - A JSON file containing all of the configuration variables used to control the execution of the Test Suite</li> <li><code>serial0.txt</code> - The serial port output from the tested device</li> <li><code>serial_terminal.txt</code> - The terminal output from text-based tests in the terminal</li> </ul> The Logs &amp; Assets tab"},{"location":"user-docs/openqa/#settings-tab","title":"Settings Tab","text":"<p>The Settings tab visually shows the most important configuration variables that affected the Test Suite. It is a subset of what's available in the <code>vars.json</code> file from the Logs &amp; Assets Tab</p> The Settings tab"},{"location":"user-docs/openqa/#dependencies-tab","title":"Dependencies Tab","text":"<p>The test suites are run in parallel by default. The Dependencies tab shows how the Test Suite depends on other suites using a schematic. The suites, upon which the Test Suite depends must be finished before it can be run. The order of execution follows the direction of the arrows.</p> The Dependencies tab"},{"location":"user-docs/openqa/#comments-tab","title":"Comments Tab","text":"<p>The comments tab gives the authorized users a place to discuss the results of a test suite. Depending on whether a discussion has arisen in the exact suite it might not contain any useful information.</p> The Comments tab <p>A test containing comments is marked with a blue speech bubble:</p> A test containing comments"},{"location":"user-docs/openqa/#next-previous-results-tab","title":"Next &amp; Previous Results Tab","text":"<p>The Next &amp; Previous Results tab gives a useful insight about the history of regression and fixes regarding the feature tested by the test suite. It shows how the selected Test Suite worked on other Products - historical, and future ones if the Product in which the selected Test Suite was run is not the newest one released.</p> The Next &amp; Previous results tab"},{"location":"user-docs/openqa/#all-tests-tab","title":"All Tests Tab","text":"<p>The All Tests tab visible on the topmost part of every page gives access to a view of the most recent test suites running and the historical runs in order, as well as tests that are currently in progress.</p> <p>Every test suite entry lists the Product for which the suite is run, the name of the suite and its status. Pressing the colorful status circle enters the test suite page exactly like when doing so from the product details page.</p> The All Tests tab, status circles marked with red rectangles"},{"location":"user-docs/openqa/#job-groups-tab","title":"Job Groups Tab","text":"<p>The Job Groups tab in the uppermost part of every page contains a drop-down list of all the Job Groups existing on this OpenQA instance. The Job Groups which don't contain any Products are not visible on the OpenQA homepage, but can be accessed using this tab.</p> The Job Groups drop down menu"},{"location":"user-docs/requirements/","title":"TrenchBoot hardware requirements","text":"<p>TrenchBoot by itself doesn't have any special requirements, just use the requirements of target OS or hypervisor as a base. However, the same can't be said about vendors DRTM implementation, and those differ between vendors.</p>"},{"location":"user-docs/requirements/#intel","title":"Intel","text":"<p>For Intel, you need a TXT-capable chipset and TXT-capable CPU. In addition, a TPM is required. It shouldn't make a difference whether it is a discrete chip (dTPM) or firmware TPM (fTPM) running in a CPU's trusted execution environment, but version (1.2 or 2.0) must be supported by the processor, or more specifically, the SINIT Authenticated Code Module (ACM) for given CPU family. Refer to Late Launch Overview for more information about the role and source of ACM.</p> <p>Depending on firmware, TXT may need to be manually enabled in setup.</p>"},{"location":"user-docs/requirements/#amd","title":"AMD","text":"<p>On AMD, DRTM implementation is tightly connected to Secure Virtual Machine (SVM) extensions. This is a virtualization technology included in all recent (last decade or even longer) CPUs. Contrary to Intel, a discrete TPM (dTPM) is required on AMD, but its version doesn't matter - the counterpart to ACM (which must be signed by Intel) is implemented by TrenchBoot with support for both TPM 1.2 and 2.0.</p> <p>Depending on firmware, SVM (which may be labeled also as virtualization or AMD-V) may need to be manually enabled in setup.</p>"},{"location":"user-docs/requirements/#caveats","title":"Caveats","text":"<p>While the above information summarizes requirements provided by respective vendors, it doesn't necessarily mean that the platform meeting those conditions will fully work. It is possible that the firmware doesn't initialize all of the parts required by DRTM, or ACM is buggy, or there is an issue with microcode that doesn't properly start a dynamic launch event. A list of such quirks can be found here.</p>"},{"location":"user-docs/test_matrix/","title":"Hardware test matrix","text":""},{"location":"user-docs/test_matrix/#modern-as-of-2025-test-results","title":"Modern (as of 2025) test results","text":"<p>These results are based on the use of TrenchBoot in combination with AEM on the specified hardware running Qubes OS.  The tests were carried out either automatically via openQA using this test or manually by installing and verifying AEM with TrenchBoot.  The procedure is very similar in both cases:</p> <ol> <li>Installation of ACMs on Intel platforms or SKL on AMD platforms.</li> <li>Installation of TrenchBoot's versions of AEM, Xen and GRUB2 (necessary until    all of the changes are upstreamed).</li> <li>AEM setup procedure which is detailed in its README.</li> <li>Reboot so that AEM has a chance to seal the secrets taking values of DRTM    PCRs into account.</li> <li>Reboot once again to verify that AEM has successfully unsealed the secrets    and PCR values are correct with respect to TPM event log.</li> <li>An extra manual step in both cases (openQA only prints event log) is to    check that hashes from the log correspond to on-disk files.</li> </ol> <p>Devices and configurations on which TrenchBoot is known to work (availability years can be approximate; automatic tests don't override manual tests):</p> Tested device TPM family Available Notes Asus KGPE-D16(AMD Opteron family 15h models 00h-0fh server)(v0.4 by @SergiiDmytruk) TPM 1.2 2005-2015 stock BIOS Dell OptiPlex 9010(v0.3 by openQA) TPM 1.2 2012-2017 coreboot SeaBIOS firmware, bad 1st entry in event log HP Thin Client t630(v0.4 by @krystian-hebel) TPM 2.0 2016-2020 CSM legacy bootBIOS updates in 2024 HP Thin Client t630(v0.5 by openQA) TPM 1.2 2016-2020 legacy boot and UEFI boot HP Thin Client t630(v0.5 by openQA) TPM 2.0 2016-2020 legacy boot and UEFI boot Dell OptiPlex 7010(v0.5 by openQA) TPM 1.2 2012-2017 legacy boot with coreboot SeaBIOS firmware Protectli VP4670(v0.5 by openQA) TPM 2.0 2022-today legacy boot and UEFI boot <p>Devices and configurations on which TrenchBoot is known to not work:</p> Tested device TPM family Available Notes Supermicro M11SDV-8CT(AMD EPYC 3000 Snowy Owl server)(v0.4 by openQA) TPM 2.0 2019-today CSM legacy boot,unexpected PCR values Dell OptiPlex 7010(v0.5 by openQA) TPM 1.2 2012-2017 UEFI boot with coreboot edk2 firmware,platform reboots with no error code"},{"location":"user-docs/test_matrix/#legacy-before-2022-test-results","title":"Legacy (before 2022) test results","text":"<p>The origin of the following results is not always known.  AMD platforms used to be tested on CI via testing-trenchboot.</p> <p>Devices and configurations on which TrenchBoot is known to work (availability years can be approximate):</p> Tested device TPM family Available Notes Intel Kaby Lake server TPM 2.0 2016-2020 UEFI firmware Intel Skylake server TPM 2.0 2015-2019 UEFI firmware Intel Tiger Lake client TPM 2.0 2020-2023 UEFI firmware PC Engines APU2 platform series(AMD family 16h models 30h-3fh embedded) TPM 1.2 2016-2023 coreboot firmware PC Engines APU2 platform series(AMD family 16h models 30h-3fh embedded) TPM 2.0 2016-2023 coreboot firmware <p>Devices and configurations on which TrenchBoot is known to not work:</p> Tested device TPM family Notes Asus KGPE-D16(AMD Opteron family 15h models 00h-0fh server) TPM 2.0 coreboot firmware TPM issue Supermicro M11SDV-8CT(AMD EPYC 3000 Snowy Owl server) TPM 2.0 UEFI boot"},{"location":"user-docs/test_matrix/#hardware-quirks-and-workarounds","title":"Hardware quirks and workarounds","text":"<p>These are difficulties/things of note one has to face when using these platforms today. They were probably more usable years ago, but something has changed in software that nobody tested on these devices and now experience isn't very smooth.</p> Device Notes Asus KGPE-D16(AMD Opteron family 15h models 00h-0fh server) IOMMU has no extended features: can't use <code>INVALIDATE_IOMMU_ALL</code> in SKL. Dell OptiPlex 9010 1. Installer has issues rebooting without <code>reboot=pci</code> kernel option. (continued) 2. Xen sometimes has issues rebooting, boot cycle is the workaround. (continued) 3. First entry in DRTM TPM event log contains the result of PCR extend operation instead of its input due to ACM bug. HP Thin Client t630 Starting Qubes OS installation in legacy mode requires extra steps (see). (Not required since Qubes R4.2.3) Supermicro M11SDV-8CT(AMD EPYC 3000 Snowy Owl server) Problematic USB controller for Qubes OS (resets the system). (continued) Works without <code>sys-usb</code> VM or if USB controller is disabled."},{"location":"user-docs/troubleshooting/","title":"Troubleshooting","text":"<p>Covering all the possible reasons why a Secure Launch might fail is beyond the scope of this document.  It only suggests what can be checked in an attempt to diagnose the issue and simple ways to address some situations.</p>"},{"location":"user-docs/troubleshooting/#firmware-settings","title":"Firmware settings","text":"<p>If problems are encountered, the first thing to check is the firmware setting on the system:</p> <ul> <li>Is the TPM enabled?</li> <li>On Intel: are VTx and VTd enabled?</li> <li>On AMD: is SVM enabled?</li> <li>Is DRTM\u00a0(TXT/SKINIT) enabled?</li> </ul>"},{"location":"user-docs/troubleshooting/#failed-start-with-intel-txt","title":"Failed start with Intel TXT","text":"<p>TXT provides a sticky error register that will contain the last error coming from TXT or the Secure Launch kernel/hypervisor.  If there was an error, the contents of TXT error register is printed by <code>slaunch</code> GRUB command from within GRUB shell after a soft reboot.  Drop into the shell by typing <code>c</code> at the GRUB menu and run:</p> <pre><code>grub&gt; slaunch\nTXT_ERRORCODE reports failure: 0xc0008001\n</code></pre> <p><code>slaunch_state</code> dumps more detailed information about the state of TXT. However, the command is of any use only after a successful <code>slaunch</code>:</p> <pre><code>grub&gt; slaunch\ngrub&gt; slaunch_state\nSecure launcher: Intel TXT\n  TXT.STS: 0x0000000000004092\n    SENTER.DONE.STS:        0\n    SEXIT.DONE.STS:         1\n    MEM-CONFIGLOCK.STS:     0\n    PRIVATEOPEN.STS:        1\n    TXT.LOCALITY1.OPEN.STS: 0\n    TXT.LOCALITY2.OPEN.STS: 0\n  TXT.ESTS: 0x00\n    TXT_RESET.STS: 0\n  TXT.E2STS: 0x0000000000000000\n    SECRETS.STS: 0\n  TXT.ERRORCODE: 0x00000000\n  TXT.DIDVID: 0x00000001b0078086\n    VID:    0x8086\n    DID:    0xb007\n    RID:    0x0001\n    ID-EXT: 0x0000\n  TXT.VER.FSBIF: 0xffffffff\n  TXT.VER.QPIIF: 0x9d003000\n    DEBUG.FUSE: 1\n  TXT.SINIT.BASE: 0x77ec0000\n</code></pre> <p>In the second case the error is <code>0x0000000</code> meaning there was no previous error because <code>SENTER</code> command wasn't used recently.  An error of the form <code>0xc0008XXX</code> is coming from the Secure Launch kernel code.  The error codes are detailed in the Linux documentation and listed in the main header file.</p> <p>Errors coming from other sources like the CPU or the SINIT ACM have different forms.  Consult the TXT documentation from Intel to determine what the error means.</p> <p>Because the error code can prevent the use of Secure Launch and is only preserved by soft reboots, a hard reboot or a power off followed by a power on can sometimes be necessary.</p>"},{"location":"user-docs/troubleshooting/#tpm-operations-suddenly-start-to-fail","title":"TPM operations suddenly start to fail","text":"<p>This may be caused by the TPM safety timer.  If your machine was not safely shut down\u00a0(e.g., due to a power loss) and it had been running for less than approximately 70 minutes\u00a0(2<sup>22</sup> ms) since, you may experience such an issue.  Simply try to reboot the machine at a later time.</p>"},{"location":"user-docs/troubleshooting/#getting-errors-from-grub","title":"Getting errors from GRUB","text":"<p>By default, GRUB doesn't print any internal errors.  This can be changed by setting <code>debug</code> variable to a list of interesting components\u00a0(as a comma- or whitespace-separated list):</p> <pre><code>set debug=slaunch\n</code></pre> <p>See GRUB's documentation for some more details.</p>"}]}